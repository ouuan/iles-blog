---
title: CS:APP ç¬¬ä¸‰ç« å­¦ä¹ ç¬”è®°
date: 2022-09-19T10:13:08+08:00
image: csapp-3.png
tags:
    - csapp
    - å­¦ä¹ ç¬”è®°
---

[CS:APP](https://csapp.cs.cmu.edu/) ç¬¬ä¸‰ç« â€œMachine-Level Representation of Programsâ€çš„å­¦ä¹ ç¬”è®°ã€‚

è¿™ç« çš„ä¸»è¦å†…å®¹ä¸ºæ±‡ç¼–ï¼ˆmachine-level programmingï¼‰ã€‚

<Excerpt />

è¿‘å¹´æ¥ï¼Œéšç€ç¼–è¯‘å™¨å’Œé«˜çº§è¯­è¨€çš„å‘å±•ï¼Œæ‰‹å†™æ±‡ç¼–ã€æœºå™¨ç çš„éœ€æ±‚è¶Šæ¥è¶Šä½ï¼Œä½†é˜…è¯»ã€ç†è§£ç¼–è¯‘å™¨çš„è¾“å‡ºåœ¨ä¼˜åŒ–ç¨‹åºæ€§èƒ½ã€é¿å…å®‰å…¨æ¼æ´ç­‰æ–¹é¢ä¾ç„¶é‡è¦ã€‚

## Program Encodings

### æ±‡ç¼–/æœºå™¨ç ä¸­çš„ç¨‹åºçŠ¶æ€

x86-64 çš„ç¨‹åºçŠ¶æ€åŒ…å«ï¼š

-   program counterï¼Œè¡¨ç¤ºå¾…æ‰§è¡Œçš„ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€ï¼Œç”¨ `%rip` è¡¨ç¤º
-   [register file](#å¯„å­˜å™¨)ï¼Œ16 ä¸ªç”¨æ¥å­˜å‚¨æ•´å‹çš„å¯„å­˜å™¨
-   [status flags](#status-flags)ï¼Œç”¨æ¥å­˜å‚¨æœ€è¿‘æ‰§è¡Œçš„è¿ç®—çš„çŠ¶æ€
-   [vector registers](#ymm-å¯„å­˜å™¨)ï¼Œç”¨æ¥å­˜å‚¨å¤šä¸ªæ•´å‹æˆ–æµ®ç‚¹æ•°

### å°† C ä»£ç ç¼–è¯‘ä¸ºæ±‡ç¼–ä»£ç 

å¯ä»¥é€šè¿‡ `gcc -S` ç”Ÿæˆæ±‡ç¼–ä»£ç ï¼Œé€šè¿‡ `gcc -Og` æ¥å¯ç”¨â€œä»¥è°ƒè¯•ä½“éªŒä¸ºç›®æ ‡çš„ä¼˜åŒ–â€ï¼ˆåæ–‡ä¸­å™è¿°çš„å¾ˆå¤šç¼–è¯‘è¡Œä¸ºéƒ½æ˜¯éœ€è¦ä¸€äº›åŸºæœ¬çš„ä¼˜åŒ–çš„ï¼Œå¦‚æœå®Œå…¨ä¸å¯ç”¨ä»»ä½•ä¼˜åŒ–ï¼Œå¯èƒ½ç¼–è¯‘ç»“æœä¼šæœ‰å¾ˆå¤§çš„å·®åˆ«ï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œå®Œå…¨ä¸ä¼˜åŒ–å’Œè¿‡åº¦ä¼˜åŒ–éƒ½ä¼šé™ä½æ±‡ç¼–ä»£ç çš„å¯è¯»æ€§ï¼‰ã€‚

ä¸ºäº†æ–¹ä¾¿ï¼Œå¯ä»¥ç”¨ä¸€æ¡å‘½ä»¤ç¼–è¯‘å¹¶ä¸ç•™æ–‡ä»¶åœ°æŸ¥çœ‹æ±‡ç¼–ä»£ç : `gcc a.c -Og -S -o - | bat -l asm`ã€‚

ä¾‹å¦‚ï¼Œä¸‹é¢çš„ä»£ç ï¼š

```c
long mult2(long, long);

void multstore(long x, long y, long *dest)
{
    long t = mult2(x, y);
    *dest = t;
}
```

ç¼–è¯‘ä¸ºå¦‚ä¸‹çš„æ±‡ç¼–ä»£ç ï¼š

```asm
	.file	"a.c"
	.text
	.globl	multstore
	.type	multstore, @function
multstore:
.LFB0:
	.cfi_startproc
	pushq	%rbx
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
	movq	%rdx, %rbx
	call	mult2@PLT
	movq	%rax, (%rbx)
	popq	%rbx
	.cfi_def_cfa_offset 8
	ret
	.cfi_endproc
.LFE0:
	.size	multstore, .-multstore
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
```

### åæ±‡ç¼–ä¸æœºå™¨ç 

å¯ä»¥é€šè¿‡ `objdump` åæ±‡ç¼–ï¼Œä¾‹å¦‚ `gcc a.c -Og -c && objdump -d a.o` å¾—åˆ°ï¼š

```asm
a.oï¼š     æ–‡ä»¶æ ¼å¼ elf64-x86-64


Disassembly of section .text:

0000000000000000 <multstore>:
   0:	53                   	push   %rbx
   1:	48 89 d3             	mov    %rdx,%rbx
   4:	e8 00 00 00 00       	call   9 <multstore+0x9>
   9:	48 89 03             	mov    %rax,(%rbx)
   c:	5b                   	pop    %rbx
   d:	c3                   	ret
```

å¯ä»¥çœ‹å‡ºï¼Œæœºå™¨ç å°±æ˜¯ä¸€ä¸² bytesï¼Œè‹¥å¹²ä¸ª bytes åˆåœ¨ä¸€èµ·è¡¨ç¤ºä¸€æ¡æŒ‡ä»¤ã€‚è€Œæ¯æ¡æŒ‡ä»¤å¯¹åº”çš„ bytes æ•°é‡ä¸åŒï¼Œä¸ operands ä¸ªæ•°ä»¥åŠæŒ‡ä»¤çš„å¸¸ç”¨ç¨‹åº¦ç›¸å…³ï¼ˆç±»ä¼¼æ‘©æ–¯ç”µç ã€UTF-8ï¼‰ã€‚

<Card title="æŒ‡ä»¤é›†çš„ referenceï¼›ATT æ ¼å¼ vs Intel æ ¼å¼">
CS:APP ä»¥åŠ gcc é»˜è®¤ä½¿ç”¨çš„æ˜¯ ATT æ ¼å¼çš„æ±‡ç¼–ï¼Œå¯ä»¥åœ¨ [Instruction Set Mapping - Oracle x86 Assembly Language Reference Manual](https://docs.oracle.com/cd/E19253-01/817-5477/enmzx/index.html) æŸ¥çœ‹ ATT æ ¼å¼æ±‡ç¼–å’Œå®é™…æŒ‡ä»¤ä¹‹é—´çš„å¯¹åº”å…³ç³»ï¼Œåœ¨ [IntelÂ® 64 and IA-32 Architectures Software Developer Manuals](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)ï¼ˆä¸‹æ–‡ä¸­ä»¥â€œIntel Manualâ€æŒ‡ä»£ï¼‰ï¼ˆä¸»è¦æ˜¯ç¬¬ 2 å·ï¼‰æŸ¥çœ‹å…·ä½“æŒ‡ä»¤çš„ referenceã€‚

ATT æ ¼å¼ä¸ Intel æ ¼å¼æœ‰ä¸€äº›å·®åˆ«ï¼Œå…¶ä¸­åœ¨æŸ¥çœ‹ reference æ—¶éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒIntel æ ¼å¼çš„æŒ‡ä»¤æ²¡æœ‰ `b/w/l/q` çš„ç±»å‹åç¼€ï¼Œå¹¶ä¸” operands çš„é¡ºåºå’Œ ATT æ ¼å¼æ°å¥½ç›¸åã€‚

</Card>

## Data Formats

ç”±äºå†å²åŸå› ï¼ŒIntel ä½¿ç”¨â€œwordâ€è¡¨ç¤º 16 bitsï¼Œè€Œç”¨â€œdouble wordâ€è¡¨ç¤º 32 bitsï¼Œç”¨â€œquad wordâ€è¡¨ç¤º 64 bitsã€‚

C è¯­è¨€ç±»å‹åœ¨ x86-64 ä¸­çš„å¤§å°ï¼š

| C è¯­è¨€ç±»å‹ |  Intel æ•°æ®ç±»å‹  |  æ±‡ç¼–åç¼€   | bytes |
| :--------: | :--------------: | :---------: | :---: |
|   `char`   |       byte       |     `b`     |   1   |
|  `short`   |       word       |     `w`     |   2   |
|   `int`    |   double word    | `l` (long)  |   4   |
|   `long`   |    quad word     |     `q`     |   8   |
|    æŒ‡é’ˆ    |    quad word     |     `q`     |   8   |
|  `float`   | single precision | `s` (short) |   4   |
|  `double`  | double precision | `l` (long)  |   8   |

æ¯ç§ç±»å‹éƒ½æœ‰ä¸€ä¸ªç”¨åœ¨æ±‡ç¼–æŒ‡ä»¤ä¸­çš„åç¼€ï¼Œè¡¨ç¤º operand çš„ç±»å‹ï¼Œä¾‹å¦‚ `movb`ã€`movw`ã€`movl`ã€`movq`ã€‚`l` æ—¢ç”¨äº double word ä¹Ÿç”¨äº double precisionï¼Œä½†æ•´æ•°å’Œæµ®ç‚¹æ•°æ¶‰åŠçš„æŒ‡ä»¤ä¸åŒï¼Œæ‰€ä»¥ä¸ä¼šæœ‰æ­§ä¹‰ã€‚ï¼ˆåæ–‡ä¸­ [Floating-Point Code](#floating-point-code) ç”¨çš„ AVX2 æŒ‡ä»¤å¹¶ä¸ä½¿ç”¨ `s`/`l` çš„æµ®ç‚¹æ•°ç±»å‹åç¼€ã€‚ï¼‰

## Accessing Information

### å¯„å­˜å™¨

x86-64 CPU æœ‰ 16 ä¸ª general-purpose registerï¼Œå¯ä»¥ç”¨æ¥å­˜æ•´æ•°æˆ–æŒ‡é’ˆï¼š

| quad word | double word |  word   |  byte   |     ç”¨é€”      |
| :-------: | :---------: | :-----: | :-----: | :-----------: |
|  `%rax`   |   `%eax`    |  `%ax`  |  `%al`  | return value  |
|  `%rbx`   |   `%ebx`    |  `%bx`  |  `%bl`  | callee saved  |
|  `%rcx`   |   `%ecx`    |  `%cx`  |  `%cl`  | 4th argument  |
|  `%rdx`   |   `%edx`    |  `%dx`  |  `%dl`  | 3rd argument  |
|  `%rsi`   |   `%esi`    |  `%si`  | `%sil`  | 2nd argument  |
|  `%rdi`   |   `%edi`    |  `%di`  | `%dil`  | 1st argument  |
|  `%rbp`   |   `%ebp`    |  `%bp`  | `%bpl`  | callee saved  |
|  `%rsp`   |   `%esp`    |  `%sp`  | `%spl`  | stack pointer |
|   `%r8`   |   `%r8d`    | `%r8w`  | `%r8b`  | 5th argument  |
|   `%r9`   |   `%r9d`    | `%r9w`  | `%r9b`  | 6th argument  |
|  `%r10`   |   `%r10d`   | `%r10w` | `%r10b` | caller saved  |
|  `%r11`   |   `%r11d`   | `%r11w` | `%r11b` | caller saved  |
|  `%r12`   |   `%r12d`   | `%r12w` | `%r12b` | callee saved  |
|  `%r13`   |   `%r13d`   | `%r13w` | `%r13b` | callee saved  |
|  `%r14`   |   `%r14d`   | `%r14w` | `%r14b` | callee saved  |
|  `%r15`   |   `%r15d`   | `%r15w` | `%r15b` | callee saved  |

æ¯ä¸ª register å¯ä»¥ç”¨å››ç§ä¸åŒçš„é•¿åº¦è®¿é—®ï¼Œå…¶ä¸­çŸ­çš„æ˜¯é•¿çš„çš„ä½ä½ã€‚ä¿®æ”¹ byte æˆ– word çš„å€¼æ—¶é«˜ä½ä¸å˜ï¼Œä¿®æ”¹ double word çš„å€¼åˆ™ä¼šå°†é«˜ä½æ¸…é›¶ã€‚

ä¸åŒå¯„å­˜å™¨çš„ç”¨é€”å°†åœ¨åæ–‡è¯´æ˜ï¼ˆä¸»è¦æ˜¯åœ¨ [Procedures](#Procedures) è¿™ä¸€èŠ‚ï¼‰ã€‚

### Operand æ ¼å¼

æŒ‡ä»¤çš„ operand æœ‰ä¸‰ç§æŒ‡å®šæ–¹å¼ï¼š

1.  Immediateï¼Œå³å­—é¢å€¼ï¼Œä»£ç ä¸º `$Imm`ï¼Œä¾‹å¦‚ `$123` è¡¨ç¤º 123ï¼Œ`$0x123` è¡¨ç¤º 0x123
2.  Registerï¼Œä»£ç ä¸ºå¯„å­˜å™¨çš„åç§°ï¼Œä¾‹å¦‚ `%rax`
3.  Memoryï¼Œå®Œæ•´å½¢æ€çš„ä»£ç ä¸º `Imm(rb, ri, s)`ï¼Œè¡¨ç¤º `M[Imm + R[rb] + R[ri] * s]`ï¼ˆå…¶ä¸­ `ri` ä¸ä¸º `%rsp`ï¼Œ$s \in \{1, 2, 4, 8\}$ï¼‰ï¼Œä¾‹å¦‚ `2(%rax, %rbx, 4)` è¡¨ç¤º memory ä¸­åœ°å€ä¸º `2 + %rax + 4 * %rbx` çš„å€¼ï¼›`Imm`ã€`rb`ã€`, ri, s` åˆ†åˆ«å¯ä»¥çœç•¥ï¼Œä¾‹å¦‚ `Imm`ã€`(rb)`ã€`Imm(, ri, s)`ï¼›æŒ‡å®šäº† `ri` æ—¶ä¹Ÿå¯ä»¥çœç•¥ `s` è¡¨ç¤º `s` ä¸º 1ã€‚

åœ¨ä¸‹æ–‡ä¸­ï¼Œç”¨ `imm32`ã€`r64`ã€`m16`ã€`r/m64` ç­‰æ–¹å¼è¡¨ç¤ºæŒ‡ä»¤ operand çš„ç±»å‹ã€‚

ï¼ˆåœ¨ ATT æ ¼å¼ä¸­ï¼‰æœ‰ä¸¤ä¸ª operand æ—¶ï¼Œç¬¬ä¸€ä¸ªæ˜¯ sourceï¼Œç¬¬äºŒä¸ªæ˜¯ destinationã€‚

### move ç±»æŒ‡ä»¤

è™½ç„¶å«â€œmoveâ€ï¼Œä½†å®é™…ä¸Šæ˜¯å¤åˆ¶ã€‚

#### MOV æŒ‡ä»¤

source å’Œ destination ç±»å‹ç›¸åŒã€‚

-   `movb imm/r8, r/m8`
-   `movb m8, r8`
-   `movw imm/r16, r/m16`
-   `movw m16, r16`
-   `movl imm/r32, r/m32`
-   `movl m32, r32`
-   `movq imm32/r64, r/m64`
-   `movq m64, r64`
-   `movabsq imm64, r64`

å…¶ä¸­ï¼Œsource å’Œ destination ä¸èƒ½åŒæ—¶æ˜¯ memoryã€‚

ç‰¹åˆ«åœ°ï¼Œ`movq` ä¸æ¥å— imm64ï¼Œå¤åˆ¶æ—¶ä¼šåœ¨ imm32 çš„é«˜ä½è¡¥ç¬¦å·ä½ï¼›`movabsq` å¯ä»¥æ¥å— imm64ï¼Œä½† destination åªèƒ½æ˜¯å¯„å­˜å™¨ã€‚è¿™æ ·è®¾è®¡çš„åŸå› å¯ä»¥å‚è€ƒ [assembly - why we can't move a 64-bit immediate value to memory? - Stack Overflow](https://stackoverflow.com/questions/62771323/why-we-cant-move-a-64-bit-immediate-value-to-memory)ã€‚å®é™…ä¸Šï¼Œæ”¯æŒ imm64 ä½œä¸º operand çš„æŒ‡ä»¤æ˜¯å°‘æ•°ï¼Œåé¢è¿˜ä¼šçœ‹åˆ°å¾ˆå¤šä¸æ¥å— imm64 çš„æŒ‡ä»¤ï¼Œä¸€èˆ¬éƒ½æ˜¯é«˜ä½è¡¥ç¬¦å·ä½ã€‚

#### MOVZ æŒ‡ä»¤

å°†é«˜ä½è¡¥é›¶åå¤åˆ¶ã€‚

-   `movzbw r/m8, r16`
-   `movzbl r/m8, r32`
-   `movzwl r/m16, r32`
-   `movzbq r/m8, r64`
-   `movzwq r/m16, r64`

æ²¡æœ‰ `movzlq` è¿™æ¡æŒ‡ä»¤ï¼Œå› ä¸ºå°†å¯„å­˜å™¨çš„å€¼ä¿®æ”¹ä¸ºä¸€ä¸ª double word æ—¶å°±ä¼šå°†é«˜ä½æ¸…é›¶ï¼Œæ‰€ä»¥ä½¿ç”¨ `movl` å°±å¯ä»¥äº†ã€‚

<Card
    type="question"
    title="æ²¡ç”¨çš„ <code>movzbq</code> å’Œ <code>movzwq</code> ğŸ¤”ï¼Ÿ"
>
    è™½ç„¶æœ‰ `movzbq` å’Œ `movzwq`ï¼Œä½†ä¸€èˆ¬ä¼šç”¨ `movzbl` å’Œ `movzwl`
    å®ç°ç›¸åº”çš„åŠŸèƒ½ã€‚æ²¡æœåˆ°ä¸ºä»€ä¹ˆä¼šæœ‰è¿™ä¸¤æ¡æŒ‡ä»¤...
</Card>

#### MOVS æŒ‡ä»¤

å°†é«˜ä½è¡¥ç¬¦å·ä½åå¤åˆ¶ã€‚

-   `movsbw r/m8, r16`
-   `movsbl r/m8, r32`
-   `movsbq r/m8, r64`
-   `movswl r/m16, r32`
-   `movswq r/m16, r64`
-   `movslq r/m32, r64`
-   `cltq`: å’Œ `movslq %eax, %rax` æ•ˆæœç›¸åŒï¼ˆä½†ç¼–ç æ›´çŸ­ï¼‰

### push/pop stack

-   `pushq imm32/r/m64`: å°† `R[%rsp]` å‡å…«ï¼Œç„¶åå°† operand å¤åˆ¶åˆ° `M[R[%rsp]]`ï¼ˆ`PUSH` æŒ‡ä»¤ä¸æ”¯æŒ imm64ï¼Œä¼šå°† imm32 é«˜ä½è¡¥ç¬¦å·ä½ï¼‰
-   `popq r/m64`: å°† `M[R[%rsp]]` å¤åˆ¶åˆ° operandï¼Œç„¶åå°† `R[%rsp]` åŠ å…«

å¯ä»¥çœ‹å‡ºï¼Œprogram stack æ˜¯ memory ä¸­è¿ç»­çš„ä¸€æ®µï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ª quad wordï¼Œtop çš„åœ°å€æ¯” bottom ä½ï¼Œpush æ—¶ stack pointer å‡å°ã€‚

ç”±äº stack ä¸è¿‡æ˜¯ç”± `%rsp` æ ‡è®°æ ˆé¡¶çš„ä¸€æ®µ memoryï¼Œå¯ä»¥é€šè¿‡ç»™ `%rsp` åŠ ä¸Šä¸€ä¸ª offset è®¿é—®éæ ˆé¡¶å…ƒç´ ï¼Œä¾‹å¦‚ `8(%rsp)` ä¸ºæ ˆé¡¶ä¸‹é¢çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚

<Card title="ä¸ºä»€ä¹ˆ top ä½äºä½åœ°å€ï¼Ÿ">
    top ä½äºä½åœ°å€å¯èƒ½çœ‹èµ·æ¥å¾ˆæ€ªï¼Œå¯ä»¥å‚è€ƒ [Why does the stack address grow
    towards decreasing memory addresses? - Stack
    Overflow](https://stackoverflow.com/questions/4560720/why-does-the-stack-address-grow-towards-decreasing-memory-addresses)ã€‚ç®€å•æ¥è¯´ï¼Œç”±äº
    memory layout å’Œ memory æ›¾ç»å¾ˆå°çš„å†å²åŸå› ï¼Œstack å’Œ heap
    ä¼šå¾€ä¸åŒçš„æ–¹å‘å¢é•¿ï¼Œæ€»ä¼šæœ‰ä¸€ä¸ªåœ¨å¢é•¿æ—¶å‡å°åœ°å€ï¼Œè€Œ x86-64 é€‰æ‹©äº† push stack
    æ—¶å‡å°åœ°å€ï¼Œè¿™ä¹Ÿä½¿å¾—è®¿é—®éæ ˆé¡¶å…ƒç´ ä¸éœ€è¦ç»™ offset åŠ è´Ÿå·ã€‚
</Card>

<Card title="<code>pushq</code>/<code>popq</code> vs ç›´æ¥ä¿®æ”¹ <code>%rsp</code>">
    é™¤äº† `pushq`/`popq`ï¼Œä¹Ÿå¯ä»¥å‡å° `%rsp` æ¥å‘æ ˆé¡¶å‹å…¥æœªåˆå§‹åŒ–çš„æ•°æ®ï¼Œæˆ–è€…å¢å¤§
    `%rsp` æ¥é‡Šæ”¾æ ˆç©ºé—´ï¼Œä½†è¿™æ ·åšå’Œ `pushq`/`popq`
    ç›¸æ¯”å“ªä¸ªæ€§èƒ½æ›´å¥½æ˜¯æ¯”è¾ƒå¤æ‚çš„ï¼Œå¯ä»¥å‚è€ƒ [assembly - What C/C++ compiler can
    use push pop instructions for creating local variables, instead of just
    increasing esp once? - Stack
    Overflow](https://stackoverflow.com/questions/49485395/what-c-c-compiler-can-use-push-pop-instructions-for-creating-local-variables)ã€‚
</Card>

## Arithmetic and Logical Operations

### Load Effective Address

`leaq m, r64`: å°† source operand çš„åœ°å€å¤åˆ¶åˆ° destination operandï¼ˆåªè®¡ç®— source operand çš„åœ°å€ï¼Œä¸å…¶æŒ‡å‘çš„ memory ä¸­å­˜å‚¨çš„å€¼æ— å…³ï¼‰

LEA å¯ä»¥ç”¨æ¥ä¼˜åŒ–ä¸€äº›ç®€å•çš„ç®—æœ¯ï¼Œä¾‹å¦‚ï¼š

```c
long scale(long x, long y, long z)
{
    long t = x + 4 * y + 12 * z;
    return t;
}
```

```asm
scale:
	leaq	(%rdi,%rsi,4), %rax
	leaq	(%rdx,%rdx,2), %rdx
	leaq	(%rax,%rdx,4), %rax
	ret
```

è¿™é‡Œä¸‰ä¸ª LEA åˆ†åˆ«è®¡ç®—äº† $x + 4y$, $z + 2z$ å’Œ $(x + 4y) + 4 (z + 2z)$ã€‚

### ä¸€å…ƒè¿ç®—

æ¯ç§ä¸€å…ƒè¿ç®—éƒ½æœ‰ b/w/l/q å››ä¸ªç±»å‹ï¼Œæ¥å—ä¸€ä¸ªç›¸åº”ç±»å‹çš„ r/mï¼Œå°†è¿™ä¸ª operand è®¡ç®—åçš„ç»“æœå­˜å…¥è¿™ä¸ª operandï¼š

-   `INC`: åŠ ä¸€
-   `DEC`: å‡ä¸€
-   `NEG`: å–å (negate)
-   `NOT`: æŒ‰ä½å–å (complement)

### äºŒå…ƒè¿ç®—

æ¯ç§äºŒå…ƒè¿ç®—éƒ½æœ‰ b/w/l/q å››ä¸ªç±»å‹ï¼Œæ¥å—ç›¸åº”ç±»å‹çš„ imm/r/m ä½œä¸º sourceï¼ˆé™¤äº† imm64ï¼‰ï¼Œç›¸åº”ç±»å‹çš„ r/m ä½œä¸º destinationï¼ˆsource å’Œ destination ä¸èƒ½åŒæ—¶ä¸º memoryï¼‰ï¼Œæ•ˆæœä¸ºå°† sourceâ€œä½œç”¨äºâ€destinationï¼Œå°†è¿ç®—ç»“æœå­˜å…¥ destinationã€‚

-   `ADD`: åŠ 
-   `SUB`: destination å‡å» source
-   `IMUL`: ä¹˜
-   `XOR`: æŒ‰ä½å¼‚æˆ–
-   `OR`: æŒ‰ä½æˆ–
-   `AND`: æŒ‰ä½ä¸

ç‰¹åˆ«åœ°ï¼Œç±»ä¼¼ `xorl %rdx, %rdx` çš„ä»£ç å¯ä»¥ç”¨æ¥ä¼˜åŒ– `movl $0, %rdx`ï¼Œå‚è§ Practice Problem 3.11 ä»¥åŠ [performance - What is the best way to set a register to zero in x86 assembly: xor, mov or and? - Stack Overflow](https://stackoverflow.com/questions/33666617/what-is-the-best-way-to-set-a-register-to-zero-in-x86-assembly-xor-mov-or-and)ã€‚

### ä½ç§»

ä½ç§»æœ‰ b/w/l/q å››ä¸ªç±»å‹ï¼Œsource åªèƒ½æ˜¯ imm8 æˆ–è€… `%cl`ï¼Œdestination æ˜¯ç›¸åº”ç±»å‹çš„ r/mã€‚

-   `SAL`/`SHL`: å·¦ç§»
-   `SAR`: ç®—æœ¯å³ç§»
-   `SHR`: é€»è¾‘å³ç§»

<Card type="question" title="å¯¹è¿‡å¤§ä½ç§»ä½æ•°çš„å¤„ç†">
    CS:APP ä¸Šè¯´ä½ç§»çš„ä½æ•°ä¼šå¯¹ operand size å–æ¨¡ï¼Œä½†æ ¹æ® Intel Manual
    ä»¥åŠæˆ‘è‡ªå·±å®éªŒçš„ç»“æœï¼Œåº”è¯¥æ˜¯ b/w/l å¯¹ 32 å–æ¨¡ï¼Œq å¯¹ 64 å–æ¨¡ï¼›errata
    ä¹Ÿæ²¡çœ‹åˆ°è¿™ä¸€æ¡ï¼Œä¸çŸ¥é“æ˜¯æ€ä¹ˆå›äº‹ã€‚
</Card>

### ç»“æœæ˜¯ operand ä¸¤å€é•¿åº¦çš„è¿ç®—

128 ä½çš„æ•´æ•°å«åš oct wordï¼Œéœ€è¦å­˜åœ¨ä¸¤ä¸ªå¯„å­˜å™¨ä¸­ï¼Œåœ¨æŒ‡ä»¤ä¸­ä¸€èˆ¬é«˜ä½æ”¾åœ¨ `R[%rdx]` ä½ä½æ”¾åœ¨ `R[%rax]`ã€‚

è™½ç„¶æˆªå»é«˜ä½æ—¶æ˜¯å¦æœ‰ç¬¦å·å¯¹ç¼–ç å±‚é¢çš„ä¹˜æ³•æ²¡æœ‰å½±å“ï¼Œä¸æˆªå»é«˜ä½æ—¶å°±éœ€è¦å¯¹ signed å’Œ unsigned ä½¿ç”¨ä¸åŒçš„æŒ‡ä»¤äº†ï¼š

-   `imulq r/m64`: è®¡ç®— operand å’Œ `R[%rax]` ä½œä¸º signed integer ç›¸ä¹˜è€Œä¸æˆªå»é«˜ä½çš„ç»“æœï¼Œå­˜åœ¨ `R[%rdx]:R[%rax]` ä¸­ã€‚ï¼ˆå¦‚æœæœ‰ä¸¤ä¸ª operand å°±æ˜¯ä¸Šé¢çš„ [äºŒå…ƒè¿ç®—](#äºŒå…ƒè¿ç®—) äº†ã€‚ï¼‰
-   `mulq r/m64`: è®¡ç®— operand å’Œ `R[%rax]` ä½œä¸º unsigned integer ç›¸ä¹˜è€Œä¸æˆªå»é«˜ä½çš„ç»“æœï¼Œå­˜åœ¨ `R[%rdx]:R[%rax]` ä¸­ã€‚

é™¤æ³•ä»¥åŠå–æ¨¡ï¼š

-   `cqto`/`cqtd`: å°† `R[%rax]` é«˜ä½å¡«ç¬¦å·ä½æ”¾åœ¨ `R[%rdx]:R[%rax]`ï¼ˆä¹Ÿå°±æ˜¯ç”¨ `R[%rax]` çš„ç¬¦å·ä½å¡«æ»¡ `R[%rdx]`ï¼‰ã€‚
-   `idivq`: è®¡ç®— `R[%rdx]:R[%rax]` æœ‰ç¬¦å·åœ°é™¤ä»¥ operandï¼Œå•†æ”¾åœ¨ `R[%rax]`ï¼Œä½™æ•°æ”¾åœ¨ `R[%rdx]`ã€‚
-   `divq`: è®¡ç®— `R[%rdx]:R[%rax]` æ— ç¬¦å·åœ°é™¤ä»¥ operandï¼Œå•†æ”¾åœ¨ `R[%rax]`ï¼Œä½™æ•°æ”¾åœ¨ `R[%rdx]`ã€‚

å¾—åˆ°çš„å•†éƒ½æ˜¯å‘ 0 å–æ•´ï¼Œæ‰€ä»¥è¢«é™¤æ•°ä¸ºè´Ÿæ—¶ä½™æ•°éæ­£ã€‚

è‹¥å•†æº¢å‡ºäº†ï¼Œåˆ™ä¼šè§¦å‘ divide error å¼‚å¸¸ã€‚æ‰€ä»¥è¢«é™¤æ•°ä¸€èˆ¬ä¼šæ˜¯ 64 ä½æ•´æ•°ï¼ˆåœ¨ `idivq` ä¹‹å‰ç”¨ `cqto` æ¥è®¾ç½® `R[%rdx]`ï¼Œåœ¨ `divq` ä¹‹å‰å°† `R[%rdx]` ç½®ä¸ºå…¨é›¶ï¼‰ï¼Œå¦åˆ™å¾ˆå¯èƒ½æº¢å‡ºè€Œè§¦å‘å¼‚å¸¸ã€‚

è¿™äº›è¿ç®—ä¹Ÿæœ‰ operand ä¸º 32 ä½ï¼Œç»“æœä¸º 64 ä½çš„ç‰ˆæœ¬ï¼š`imull`ã€`mull`ã€`cltd`ã€`idivl`ã€`divl`ã€‚å®ƒä»¬ä»¥ `%edx` å’Œ `%eax` æ¥ä»£æ›¿ 128 ä½è¿ç®—ä¸­çš„ `%rdx` å’Œ `%rax`ã€‚

## Control

<Card type="hint" title="â€œstatus flagâ€ vs â€œcondition codeâ€">
    åœ¨ CS:APP ä¸­ `CF`/`ZF`/`SF`/`OF` ç­‰è¢«å«åšâ€œcondition codeâ€ï¼›è€Œåœ¨ Intel Manual
    ä¸­ï¼Œ`CF`/`ZF`/`SF`/`OF` ç­‰è¢«å«åšâ€œstatus flagâ€ï¼Œâ€œcondition codeâ€æŒ‡çš„æ˜¯ status
    flags çš„ç»„åˆã€‚ä¸‹æ–‡é‡‡ç”¨ Intel çš„å«æ³•ã€‚
</Card>

### Status Flags

status flags ä¸­å­˜å‚¨äº†æœ€è¿‘ä¸€æ¬¡è¿ç®—çš„çŠ¶æ€ï¼Œå¸¸ç”¨çš„ status flag æœ‰å››ä¸ªï¼š

-   `CF`: Carry Flagï¼Œè¡¨ç¤ºè¿ç®—è¿‡ç¨‹ä¸­å‘ç”Ÿäº†è¶…å‡º operand é•¿åº¦çš„è¿›ä½æˆ–å€Ÿä½ï¼Œå³å°†è¿ç®—è§†ä½œ unsigned å‘ç”Ÿäº†æº¢å‡ºã€‚
-   `ZF`: Zero Flagï¼Œè¡¨ç¤ºè¿ç®—ç»“æœä¸ºé›¶ã€‚
-   `SF`: Sign Flagï¼Œè¡¨ç¤ºè¿ç®—ç»“æœï¼ˆçœ‹ä½œè¡¥ç ï¼‰ä¸ºè´Ÿï¼Œå³è¿ç®—ç»“æœçš„ç¬¦å·ä½ã€‚
-   `OF`: Overflow Flagï¼Œè¡¨ç¤ºè‹¥å°†è¿ç®—è§†ä½œ signed å‘ç”Ÿäº†æº¢å‡ºã€‚

<Card title="ARM ä¸­çš„ carry flag â€”â€” carry flag vs borrow flag" fold>
åœ¨ ARM ä¸­ï¼Œè®¡ç®—å‡æ³•æ—¶ï¼Œä¸ x86 ç›¸åï¼Œcarry flag ä¸º 0 è¡¨ç¤ºæº¢å‡ºï¼Œä¸º 1 è¡¨ç¤ºæ²¡æœ‰æº¢å‡ºã€‚

è¿™æ˜¯å› ä¸ºï¼Œè®¡ç®—å‡æ³•æœ‰ä¸¤ç§æ–¹å¼ï¼Œ[subtract with borrow å’Œ subtract with carry](https://en.wikipedia.org/wiki/Carry_flag#Vs._borrow_flag)ï¼š

-   subtract with borrow ç›¸å½“äºæ™®é€šçš„å‡æ³•ç«–å¼è®¡ç®—ï¼Œè®¡ç®—è¿‡ç¨‹ä¸­è®°å½• borrow flagï¼Œæœ€åå­˜å‚¨åœ¨ carry flag ä¸­ï¼Œè¡¨ç°ä¸ºè‹¥æœ€åå‘ç”Ÿå€Ÿä½åˆ™ carry flag ä¸º 1ã€‚
-   subtract with carry åˆ©ç”¨äº† `-x = ~x + 1` çš„æ€§è´¨ï¼Œé€šè¿‡ `a + ~b + 1` æ¥è®¡ç®— `a - b`ï¼Œè€Œå’Œæ™®é€šåŠ æ³•ä¸€æ ·è®¡ç®— carry flagï¼›è€Œåœ¨ subtract with borrow æœ€åå‘ç”Ÿå€Ÿä½æ—¶ï¼Œsubtract with carry åè€Œ carry flag æ˜¯ 0ã€‚

å¯ä»¥è¿™ä¹ˆç†è§£è¿™ä¸¤è€…é—´çš„å·®å¼‚ï¼šè®¾è®¡ç®—æ˜¯ $w$ ä½çš„ï¼Œæœ€åè®¡ç®—å®Œæˆæ—¶ï¼Œborrow flag è¡¨ç¤ºç¬¬ $w+1$ ä½ä¸Šæ˜¯ $-1$ï¼Œcarry flag è¡¨ç¤ºç¬¬ $w+1$ ä½ä¸Šæ˜¯ $1$ï¼Œè€Œ subtract with carry ç›¸å½“äºå…ˆåŠ ä¸Šäº† $2^w$ å†è¿›è¡Œå‡æ³•ï¼Œå°±ä¼šå°†ç¬¬ $w+1$ ä½ä» $-1$ å˜æˆ $0$ï¼Œä» $0$ å˜æˆ $1$ã€‚
</Card>

LEA ä¸ä¼šæ”¹å˜ status flagsã€‚

[ä¸€å…ƒè¿ç®—](#ä¸€å…ƒè¿ç®—) å’Œ [äºŒå…ƒè¿ç®—](#äºŒå…ƒè¿ç®—) éƒ½ä¼šæ”¹å˜ status flagsã€‚ç‰¹åˆ«åœ°ï¼Œ`INC` å’Œ `DEC` ä¸ä¼šæ”¹å˜ `CF`ã€‚

ä½ç§»å¯¹ status flags çš„å½±å“æ¯”è¾ƒå¤æ‚ï¼ˆå¯ä»¥å‚è€ƒ Intel Manualï¼‰ï¼Œç®€å•æ¥è¯´ `CF` ä¼šè¢«è®¾ä¸ºæœ€åä¸€ä¸ªç§»å‡ºçš„ä½ï¼Œåªæœ‰ä½ç§»ä½æ•°ä¸º 1 æ—¶æ‰ä¼šæ”¹å˜ `OF`ã€‚

### Condition Codes

condition code æ˜¯ status flags çš„ç»„åˆï¼Œå¸¸ç”¨çš„æœ‰ï¼š

| condition code |               åç§° (æ„ä¹‰)                |        å–å€¼        |
| :------------: | :--------------------------------------: | :----------------: |
|    `e`/`z`     |               equal / zero               |        `ZF`        |
|   `ne`/`nz`    |           not equal / not zero           |       `~ZF`        |
|      `s`       |             sign (negative)              |        `SF`        |
|      `ns`      |         not sign (non-negative)          |       `~SF`        |
|   `g`/`nle`    |  greater / not less equal (signed $>$)   | `~(SF ^ OF) & ~ZF` |
|   `ge`/`nl`    | greater equal / not less (signed $\ge$)  |    `~(SF ^ OF)`    |
|   `l`/`nge`    |  less / not greater equal (signed $<$)   |     `SF ^ OF`      |
|   `le`/`ng`    | less equal / not greater (signed $\le$)  | `(SF ^ OF) \| ZF`  |
|   `a`/`nbe`    |  above / not below equal (unsigned $>$)  |    `~CF & ~ZF`     |
|   `ae`/`nb`    | above equal / not below (unsigned $\ge$) |       `~CF`        |
|   `b`/`nae`    |  below / not above equal (unsigned $<$)  |        `CF`        |
|   `be`/`na`    | below equal / not above (unsigned $\le$) |     `CF \| ZF`     |

è¿™äº› condition code éƒ½æ˜¯æŒ‰ç…§å‡æ³•çš„ç»“æœæ¥å‘½åçš„ï¼Œåœ¨ä½¿ç”¨ `CMP` æŒ‡ä»¤æ—¶è¿™äº›åç§°æ˜¯è‡ªç„¶çš„ï¼Œä½†å¦‚æœä¸æ˜¯ `CMP`/`SUB` åˆ™è¦è€ƒè™‘è¿›è¡Œçš„è¿ç®—æ˜¯ä»€ä¹ˆä»¥åŠæ¯ä¸ª condition code å®é™…çš„å–å€¼ã€‚

`l`/`nge` å¯ä»¥ç†è§£ä¸ºï¼Œæº¢å‡ºåä¼šå˜å·ï¼Œæ‰€ä»¥ `SF ^ OF` å°±æ˜¯å¦‚æœä¸æº¢å‡ºçš„ç¬¦å·ï¼›`b`/`nae` æ˜¯å› ä¸ºå‡æ³•å‘ç”Ÿå€Ÿä½æ—¶ä¼šæ ‡è®° `CF`ã€‚

### CMP å’Œ TEST æŒ‡ä»¤

å¦‚æœçœŸçš„è¿›è¡Œè¿ç®—ï¼Œdestination çš„å€¼ä¼šè¢«è¦†ç›–ï¼Œæ‰€ä»¥ï¼Œå¦‚æœè®¡ç®—ç»“æœæ˜¯ä¸éœ€è¦çš„ï¼Œä¸€èˆ¬ä¼šç”¨ `CMP` å’Œ `TEST` æ¥è·å– status flagsã€‚

`CMP` å’Œ `TEST` çš„ operands å’Œ [äºŒå…ƒè¿ç®—](#äºŒå…ƒè¿ç®—) ç›¸åŒã€‚

`CMP` ç›¸å½“äºæ‰§è¡Œ `SUB` ä½†åªæ›´æ–° status flags ä¸æ›´æ–° destinationã€‚å¸¸ç”¨äºæ¯”è¾ƒä¸¤ä¸ªæ•°çš„å¤§å°ã€‚

<Card type="warn" title="CMP çš„æ¯”è¾ƒé¡ºåº">
    ç”±äº ATT æ ¼å¼çš„æ±‡ç¼–æ˜¯ source åœ¨å‰ destination åœ¨åï¼Œ `CMP` çš„å‡æ³•æ˜¯
    destination å‡å» sourceï¼Œ æ‰€ä»¥æ¯”è¾ƒæ˜¯çœ‹èµ·æ¥æ˜¯åçš„ï¼Œä¾‹å¦‚ `l` å…¶å®æ˜¯ç¬¬äºŒä¸ª
    operand å°äºç¬¬ä¸€ä¸ª operandã€‚
</Card>

`TEST` ç›¸å½“äºæ‰§è¡Œ `AND` ä½†åªæ›´æ–° status flags ä¸æ›´æ–° destinationã€‚å¸¸è§çš„ç”¨æ³•æœ‰ä¸¤ç§ï¼Œä¸€ç§æ˜¯ä¸¤ä¸ª operand ä¸ºåŒä¸€ä¸ªå¯„å­˜å™¨ä»¥åˆ¤æ–­å…¶ç¬¦å·ï¼Œå¦ä¸€ç§æ˜¯ source ä¸º bit maskã€‚

### SETcc æŒ‡ä»¤

`SETcc r/m8`: å°† `cc` å¤åˆ¶åˆ° operand å¤„ã€‚å…¶åç¼€ä¸æ˜¯ operand çš„é•¿åº¦ï¼Œè€Œæ˜¯ condition codeï¼Œä¾‹å¦‚ `sete r/m8`ã€`setne r/m8`ã€`sets r/m8`...

### Jump ç±»æŒ‡ä»¤

#### Label

åœ¨æ±‡ç¼–ä¸­ jump é€šå¸¸ä¼šä½¿ç”¨ label ä½œä¸º jump targetï¼Œä¾‹å¦‚ï¼ˆCS:APP P205ï¼‰ï¼š

```asm
    movq $0, %rax
    jmp  .L1
    movq (%rax), %rdx
.L1:
    popq %rdx
```

è¿™é‡Œçš„ `.L1` å°±æ˜¯ä¸€ä¸ª labelã€‚

#### æ— æ¡ä»¶è·³è½¬

-   `jmp Label`: è·³è½¬åˆ° `Label` å¤„
-   `jmp *r/m64`: è·³è½¬åˆ° operand å­˜å‚¨çš„ jump target å¤„ï¼Œä¾‹å¦‚ `jmp *%rax`ã€`jmp *(%rax)`ã€‚

#### æ¡ä»¶è·³è½¬

`Jcc Label`: å¦‚æœæ»¡è¶³ `cc`ï¼Œåˆ™è·³è½¬åˆ° `Label` å¤„ã€‚

#### rep; ret

å¦‚æœ `ret` ä¼šä½œä¸ºæŸä¸ªåˆ†æ”¯çš„ç¬¬ä¸€æ¡æŒ‡ä»¤ï¼ˆå³ jump æŒ‡ä»¤çš„ä¸‹ä¸€æ¡æŒ‡ä»¤æˆ– jump targetï¼‰ï¼Œä¸€èˆ¬ä¼šæŠŠ `ret` æ¢æˆ `rep; ret`ï¼Œæ•ˆæœå’Œ `ret` ä¸€æ ·ï¼Œä½†å¯ä»¥é¿å…é”™è¯¯çš„åˆ†æ”¯é¢„æµ‹ï¼Œä»è€Œä¼˜åŒ–æ€§èƒ½ã€‚å…·ä½“å¯ä»¥å‚è€ƒ [repz ret - repz ret](https://repzret.org/p/repzret/)ã€‚

#### jump æŒ‡ä»¤ç¼–ç 

åœ¨è¿›è¡Œæ±‡ç¼–æ—¶ï¼Œlabel ä¼šè¢«æ›¿æ¢ä¸º _jump æŒ‡ä»¤çš„**ä¸‹ä¸€æ¡**æŒ‡ä»¤ï¼ˆå…¶å®å°±æ˜¯ program counter çš„å€¼ï¼‰åˆ° jump target çš„åœ°å€å·®_ã€‚è€Œåœ¨é“¾æ¥æ—¶ï¼Œè™½ç„¶æŒ‡ä»¤çš„åœ°å€å˜äº†ï¼Œä½†æŒ‡ä»¤ä¹‹é—´ç›¸å¯¹çš„åœ°å€å·®ä¸å˜ï¼Œåˆ™ jump æŒ‡ä»¤ä¸ç”¨æ”¹å˜ã€‚

ä¾‹å¦‚ï¼ˆCS:APP P207ï¼‰ï¼š

```asm
    movq %rdi, %rax
    jmp .L2
.L3:
    sarq %rax
.L2:
    testq %rax, %rax
    jg .L3
    rep; ret
```

æ±‡ç¼–åï¼š

```asm
   0:	48 89 f8             	mov    %rdi,%rax
   3:	eb 03                	jmp    0x8
   5:	48 d1 f8             	sar    %rax
   8:	48 85 c0             	test   %rax,%rax
   b:	7f f8                	jg     0x5
   d:	f3 c3                	repz ret
```

è¿™é‡Œ `jmp .L2` çš„ operand ç¼–ç ä¸º `0x03`ï¼Œå³å…¶ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€ `0x5` åˆ° jump target `0x8` çš„è·ç¦»ï¼›`jg .L3` çš„ operand ç¼–ç ä¸º `0xf8` å³ -8ï¼Œä¹Ÿå°±æ˜¯å…¶ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€ `0xd` åˆ° jump target `0x5` çš„è·ç¦»ã€‚

é“¾æ¥åï¼š

```asm
000000000000112e <foo>:
    112e:       48 89 f8                mov    %rdi,%rax
    1131:       eb 03                   jmp    1136 <foo+0x8>
    1133:       48 d1 f8                sar    %rax
    1136:       48 85 c0                test   %rax,%rax
    1139:       7f f8                   jg     1133 <foo+0x5>
    113b:       f3 c3                   repz ret
```

### CMOVcc æŒ‡ä»¤

`CMOVcc` å¯ä»¥åœ¨æ»¡è¶³ `cc` æ—¶å°† source å¤åˆ¶åˆ° destinationã€‚è¿™æ¡æŒ‡ä»¤åœ¨ ATT æ ¼å¼ä¸­æ²¡æœ‰é•¿åº¦ç±»å‹åç¼€ï¼Œé€šè¿‡ destination register çš„é•¿åº¦æ¥æ¨æ–­ç±»å‹ã€‚ä¸æ¥å— byte ä½œä¸º operandã€‚

-   `CMOVcc r/m16, r16`
-   `CMOVcc r/m32, r32`
-   `CMOVcc r/m64, r64`

### å®ç° if-else è¯­å¥

å®ç° if-else è¯­å¥ä¸»è¦æœ‰ä¸¤ç§æ–¹å¼ï¼š

1.  Conditional control: å³é€šè¿‡ jump æŒ‡ä»¤æ›´æ”¹æŒ‡ä»¤æ‰§è¡Œçš„é¡ºåºã€‚
2.  Conditional moves: å³é€šè¿‡ `CMOVcc` ç­‰æŒ‡ä»¤ï¼Œæ ¹æ®æ¡ä»¶å†³å®šæ˜¯å¦æ‰§è¡Œè¿™ä¸€æ¡æŒ‡ä»¤ï¼Œä½†ä¸æ”¹å˜æŒ‡ä»¤æ‰§è¡Œçš„é¡ºåºã€‚

ï¼ˆå…·ä½“å®ç°æ–¹å¼å¯ä»¥å‚è€ƒ CS:APP ä¸­çš„ä¾‹å­ã€‚ï¼‰

conditonal control æ˜¯é€šç”¨çš„ï¼Œä½† conditonal moves åªåœ¨æœ‰é™çš„æƒ…å†µä¸‹å¯ä»¥ä½¿ç”¨ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œä½¿ç”¨ conditional moves æ—¶éœ€è¦å…ˆå°†ä¸¤ä¸ªåˆ†æ”¯éƒ½ç®—å‡ºæ¥ï¼Œç„¶åæ ¹æ®æ¡ä»¶æ¥è¿›è¡Œ moveï¼Œæ‰€ä»¥è¦æ±‚åˆ†æ”¯ä¸­æ²¡æœ‰å‰¯ä½œç”¨ã€‚

conditional moves æœ‰æ—¶å¯ä»¥ç”¨æ¥ä¼˜åŒ–æ€§èƒ½ï¼Œä¸»è¦æ˜¯å› ä¸ºç°ä»£å¤„ç†å™¨çš„ _pipelining_ï¼Œå³åœ¨ç‰©ç†ä¸ŠåŒæ—¶æ‰§è¡Œå¤šæ¡æŒ‡ä»¤ï¼ˆä½†åœ¨æ•ˆæœä¸Šå’ŒæŒ‰é¡ºåºæ‰§è¡Œä¸€è‡´ï¼‰ã€‚æ¡ä»¶è·³è½¬ä½¿å¾—å¤„ç†å™¨ä¸èƒ½ç¡®å®šæœªæ¥è¦æ‰§è¡Œå“ªäº›æŒ‡ä»¤ï¼Œè€Œåªèƒ½è¿›è¡Œåˆ†æ”¯é¢„æµ‹ï¼Œå¦‚æœé¢„æµ‹å¤±è´¥ pipelining å°±ç™½è´¹äº†ã€‚è€Œ conditional move ä¸ä¼šç ´åæŒ‡ä»¤æ‰§è¡Œçš„é¡ºåºï¼Œä¹Ÿå°±ä¸å½±å“ pipeliningï¼Œæ‰€ä»¥å¯ä»¥èµ·åˆ°ä¼˜åŒ–çš„æ•ˆæœã€‚ä½†æ˜¯ï¼Œconditional moves é™¤äº†è¦æ±‚åˆ†æ”¯æ— å‰¯ä½œç”¨ï¼Œè¿˜éœ€è¦ä¸¤ä¸ª branch éƒ½æ‰§è¡Œï¼Œæ‰€ä»¥å¦‚æœåˆ†æ”¯è¿‡å¤§ï¼Œå°±ä¸å¦‚ conditional controlã€‚

### å®ç°å¾ªç¯è¯­å¥

`do while`: è·‘å®Œä¸€æ®µä»£ç åè¿›è¡Œæµ‹è¯•ï¼Œé€šè¿‡åˆ™è·³è½¬åˆ°å¼€å¤´ã€‚

`while`: åœ¨ `do while` çš„åŸºç¡€ä¸Šï¼Œè¦ä¹ˆåœ¨å¼€å¤´ç›´æ¥è·³è½¬åˆ°æµ‹è¯• (jump to middle)ï¼Œè¦ä¹ˆåœ¨å¼€å¤´è¿›è¡Œä¸€æ¬¡æµ‹è¯•ï¼Œä¸é€šè¿‡åˆ™è·³åˆ°ç»“å°¾ (guarded do)ã€‚

`for`: åœ¨ `while` çš„åŸºç¡€ä¸Šï¼Œå¼€å¤´åˆå§‹åŒ–ï¼Œæµ‹è¯•å‰æ›´æ–°ã€‚

### å®ç° switch è¯­å¥

å…·ä½“ä¾‹å­å¯ä»¥å‚è€ƒ CS:APPï¼Œé‡ç‚¹åœ¨äºï¼Œå¦‚æœ cases çš„å€¼ä¸è¿‡äºç¨€ç–ï¼Œå¯ä»¥å»ºä¸€ä¸ªå«åš jump table çš„æ•°ç»„ï¼Œä»¥ cases çš„å€¼ä½œä¸ºä¸‹æ ‡ï¼Œlabel ä½œä¸ºå€¼ï¼Œè¿™æ ·å°±å¯ä»¥ç”¨ä¸€æ¬¡æ•°ç»„è®¿é—®è€Œéå¤šæ¬¡æ¡ä»¶è·³è½¬æ¥å®ç° `switch` è¯­å¥ã€‚jump table ä¹Ÿå¯ä»¥å’Œæ¡ä»¶è·³è½¬ç»“åˆï¼Œä»¥å¤„ç† default case æˆ–è€…ä¸ªåˆ« casesã€‚

## Procedures

procedure çš„å®ç°ä¸»è¦æ¶‰åŠä¸‰ä¸ªæ–¹é¢ï¼š

-   åœ¨ä¸åŒçš„ procedure ä¹‹é—´è½¬ç§»æ§åˆ¶æƒï¼Œå³è°ƒç”¨ procedure æ—¶äº¤å‡ºæ§åˆ¶æƒï¼Œprocedure è¿”å›æ—¶æ‹¿å›æ§åˆ¶æƒ
-   ä¼ é€’å‚æ•°å’Œè¿”å›å€¼
-   ä¸ºå±€éƒ¨å˜é‡åˆ†é…/é‡Šæ”¾å†…å­˜

è°ƒç”¨ procedure çš„æ ¸å¿ƒæ˜¯åœ¨ [push/pop stack](#push-pop-stack) ä¸€èŠ‚ä¸­ä»‹ç»è¿‡çš„ runtime stackã€‚å¤§ä½“ä¸Šæ¥è®²ï¼Œstack ä¼šåˆ†æˆä¸€å † frameï¼Œæ ˆé¡¶çš„ frame ä¸ºå½“å‰ procedure çš„ç›¸å…³æ•°æ®ï¼Œä»æ ˆé¡¶åˆ°æ ˆåº•çš„å„ä¸ª frame ä¾æ¬¡æ”¾ç€è°ƒç”¨é“¾ä¸Šçš„å„ä¸ª procedureï¼Œåœ¨è°ƒç”¨ä¸€ä¸ª procedure æ—¶ä¼šå°†ç›¸å…³æ•°æ®å‹å…¥æ ˆä¸­ï¼Œè¿”å›æ—¶å†å¼¹å‡ºã€‚

è¿™éƒ¨åˆ†ä¼šé‡‡å–â€œç®€ä»‹-åŸåˆ™-å®ç°â€çš„ç»“æ„ï¼Œå…ˆç®€å•ä»‹ç»å¤§æ¦‚æ˜¯ä»€ä¹ˆæ ·çš„ï¼Œå†è¯´æ˜å®ç°éœ€è¦éµå¾ªçš„åŸåˆ™ï¼Œå†è¯´æ˜å…·ä½“å®ç°ï¼Œä»¥åŠå®ç°æ˜¯å¦‚ä½•æ»¡è¶³ä»¥åŠåˆ©ç”¨åŸåˆ™çš„ã€‚

### è½¬ç§»æ§åˆ¶æƒ

è°ƒç”¨ procedure æ—¶ï¼Œä¼šå°†å½“å‰ program counter çš„å€¼å­˜åœ¨ stack ä¸­ï¼Œç„¶åå°† program counter ä¿®æ”¹ä¸º calleeï¼Œåœ¨è¿”å›æ—¶å†ä» stack ä¸­å–å‡º caller çš„åœ°å€è®¾ä¸º program counterã€‚

<Card type="hint" title="å­˜æ”¾ caller åœ°å€çš„åŸåˆ™">
è¿›å…¥ä¸€ä¸ª procedure æ—¶ï¼Œæ ˆé¡¶æ”¾çš„æ˜¯ caller çš„åœ°å€ï¼ˆå…·ä½“æ¥è¯´ï¼Œæ˜¯ `call` æŒ‡ä»¤çš„ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€ï¼‰ã€‚

è¿”å›æ—¶ï¼Œè¿™ä¸ª caller çš„åœ°å€ä¼šå‡ºæ ˆï¼Œå³è¿”å›åçš„ `%rsp` æ˜¯è¿›å…¥æ—¶çš„ `%rsp` åŠ  8ã€‚

</Card>

å…·ä½“å®ç°ä¼šä½¿ç”¨ `CALL` å’Œ `RET` ä¸¤æ¡æŒ‡ä»¤ï¼š

-   `call Label`
-   `call *(r/m64)`
-   `ret`

å…¶ä¸­ `call` çš„ operand å’Œ `jmp` æ˜¯ä¸€æ ·çš„ï¼Œæ•ˆæœç›¸å½“äºå…ˆ `pushq %rip` å† `jmp`ã€‚`ret` åˆ™ç›¸å½“äºæŠŠ `popq` çš„ç»“æœä½œä¸º `jmp` çš„ operandã€‚

### ä¼ é€’å‚æ•°

å¯„å­˜å™¨ä¸­æœ‰ 6 ä¸ªç”¨æ¥å­˜æ”¾ procedure çš„ argumentsï¼Œå¦‚æœå‚æ•°å¤šäº 6 ä¸ªï¼Œåˆ™ä¼šæ”¾åœ¨ stack ä¸­ã€‚

| bits |   1    |   2    |   3    |   4    |   5    |   6    |
| :--: | :----: | :----: | :----: | :----: | :----: | :----: |
|  64  | `%rdi` | `%rsi` | `%rdx` | `%rcx` | `%r8`  | `%r9`  |
|  32  | `%edi` | `%esi` | `%edx` | `%ecx` | `%r8d` | `%r9d` |
|  16  | `%di`  | `%si`  | `%dx`  | `%cx`  | `%r8w` | `%r9w` |
|  8   | `%dil` | `%sil` | `%dl`  | `%cl`  | `%r8b` | `%r9b` |

<Card type="hint" title="å­˜æ”¾å‚æ•°çš„åŸåˆ™">
    è¿›å…¥ procedure æ—¶ï¼Œå‰ 6 ä¸ªå‚æ•°ï¼ˆå¦‚æœæœ‰ï¼‰ä¼šè¢«æ”¾åœ¨ç›¸åº”çš„å¯„å­˜å™¨ä¸­ï¼›å…¶ä½™å‚æ•°æ”¾åœ¨
    stack ä¸­ï¼Œå…·ä½“æ¥è¯´ï¼Œç¬¬ $n$ ä¸ªå‚æ•°è¢«æ”¾åœ¨æ ˆé¡¶ä¸‹é¢çš„ç¬¬ $n-6$ ä¸ªä½ç½®ï¼Œä¹Ÿå°±æ˜¯
    `M[R[%rsp] + 8(n-6)]`ã€‚
</Card>

å…·ä½“å®ç°ä¸ºï¼š

-   åœ¨ caller ä¸­ã€`call` ä¹‹å‰ï¼šå°†å‰ 6 ä¸ªå‚æ•°æ”¾åœ¨ç›¸åº”çš„å¯„å­˜å™¨ï¼Œå¹¶å°†å…¶ä½™å‚æ•°æŒ‰ä»åå‘å‰çš„é¡ºåºä¾æ¬¡å‹å…¥ stack
-   åœ¨ caller ä¸­ã€`call` ä¹‹åï¼šæŠŠ stack ä¸­çš„å‚æ•°ï¼ˆå¦‚æœæœ‰ï¼‰å¼¹å‡º (`addq $8(n-6), %rsp`)
-   åœ¨ callee ä¸­ï¼šä»ç›¸åº”çš„å¯„å­˜å™¨æˆ– stack ä¸­è¯»å–å‚æ•°

### ä¼ é€’è¿”å›å€¼

<Card type="hint" title="å­˜æ”¾è¿”å›å€¼çš„åŸåˆ™">
    åœ¨è°ƒç”¨ procedure å¹¶è¿”å›åï¼Œå¦‚æœè¯¥ procedure æœ‰è¿”å›å€¼ï¼Œ`%rax`
    ä¸­å­˜æ”¾çš„æ˜¯è¯¥è¿”å›å€¼ã€‚
</Card>

å…·ä½“å®ç°å°±æ˜¯åœ¨ `ret` å‰ç¡®ä¿ `%rax` ä¸­æ”¾çš„æ˜¯è¿”å›å€¼ã€‚

### å­˜å‚¨å±€éƒ¨å˜é‡

å±€éƒ¨å˜é‡ä¸€èˆ¬ä¼šä¼˜å…ˆæ”¾åœ¨å¯„å­˜å™¨ä¸­ï¼Œå¦‚æœæ”¾ä¸ä¸‹å°±ä¼šæ”¾åœ¨ stack ä¸­ã€‚

ç‰¹åˆ«åœ°ï¼Œå¦‚æœä»£ç ä¸­æ¶‰åŠåˆ°å–å±€éƒ¨å˜é‡çš„åœ°å€ï¼Œæˆ–è€…å±€éƒ¨å˜é‡æ˜¯ç»“æ„åŒ–æ•°æ®ï¼ˆä¾‹å¦‚æ•°ç»„æˆ–ç»“æ„ä½“ï¼‰ï¼Œåˆ™å¿…é¡»æ”¾åœ¨ stack ä¸­ã€‚

å¦‚æœå±€éƒ¨å˜é‡æ”¾åœ¨å¯„å­˜å™¨ä¸­ï¼Œä¸”åœ¨ä½¿ç”¨è¯¥å±€éƒ¨å˜é‡çš„è¿‡ç¨‹ä¸­è°ƒç”¨äº† procedureï¼Œé‚£ä¹ˆè¯¥å±€éƒ¨å˜é‡å°±ä¼šéœ€è¦å…ˆå­˜èµ·æ¥ä»¥ä¿è¯è°ƒç”¨ procedure ä¹‹åä¸ä¼šæ”¹å˜ï¼Œè€Œè¿™æœ‰ä¸¤ç§æ–¹å¼å®ç°ï¼š

-   caller savedï¼Œå³åœ¨ caller ä¸­å°†å¯„å­˜å™¨é‡Œçš„å€¼å­˜åœ¨ stack é‡Œã€‚
-   callee savedï¼Œå³åœ¨ callee ä¸­å­˜å‚¨ï¼šæœ‰ä¸€äº›ç‰¹æ®Šçš„å¯„å­˜å™¨æ˜¯ callee-saved registerï¼Œå¦‚æœæŠŠå±€éƒ¨å˜é‡å­˜åœ¨è¿™äº›å¯„å­˜å™¨ä¸­ï¼Œåœ¨ caller ä¸­å°±ä¸ç”¨æ‹…å¿ƒå®ƒä»¬çš„å€¼ä¼šåœ¨è°ƒç”¨ procedure åè¢«ä¿®æ”¹ã€‚

<Card type="hint" title="callee-saved registers çš„ä½¿ç”¨åŸåˆ™">
æœ‰ 6 ä¸ªç‰¹æ®Šçš„å¯„å­˜å™¨ `%rbx`ã€`%rbp`ã€`%r12-15` æ˜¯ callee-saved registerã€‚

ä»»ä½• procedure éƒ½è¦ä¿è¯ï¼Œæ¯ä¸ª callee-saved register çš„å€¼åœ¨è¿›å…¥å’Œè¿”å›æ—¶æ˜¯ç›¸åŒçš„ã€‚

</Card>

caller saved çš„å…·ä½“å®ç°ï¼šåœ¨ `call` ä¹‹å‰ï¼ˆä»¥åŠå‹å…¥è¶…è¿‡ 6 ä¸ªçš„å‚æ•°ä¹‹å‰ï¼‰å°†å±€éƒ¨å˜é‡å…¥æ ˆï¼Œ`call` ä¹‹åï¼ˆä»¥åŠå¼¹å‡ºæ”¾åœ¨æ ˆä¸­çš„å‚æ•°ä¹‹åï¼‰å†æŠŠæ ˆä¸­å­˜çš„å¼¹å‡ºåˆ°å¯„å­˜å™¨ä¸­ã€‚

callee saved çš„å…·ä½“å®ç°ï¼šå¦‚æœä¸€ä¸ª procedure ä½¿ç”¨äº†æŸä¸ª callee-saved registerï¼Œåˆ™è¦åœ¨ procedure çš„å¼€å¤´å°†è¿™ä¸ªå¯„å­˜å™¨åŸæœ¬çš„å€¼å…¥æ ˆï¼Œè€Œåœ¨ procedure çš„ç»“å°¾å°†å­˜ä¸‹æ¥çš„è¿™ä¸ªåŸæœ¬çš„å€¼å¼¹å‡ºåˆ°ç›¸åº”çš„å¯„å­˜å™¨ä¸­ã€‚

ä¸ºäº†å°½å¯èƒ½ä½¿ç”¨ï¼ˆæ•°é‡å°½é‡å°‘çš„ï¼‰å¯„å­˜å™¨è€Œé stackï¼Œç»å¸¸ä¼šæœ‰å¤šä¸ªç”Ÿå‘½å‘¨æœŸä¸äº¤å‰çš„çš„å˜é‡å…±ç”¨ä¸€ä¸ªå¯„å­˜å™¨ï¼Œæˆ–è€…ä¸´æ—¶åœ°æŠŠå±€éƒ¨å˜é‡æ”¾åœ¨ä¸€èˆ¬ç”¨äºå­˜æ”¾å‚æ•°æˆ–è¿”å›å€¼çš„å¯„å­˜å™¨ä¸­ã€‚

### å¯å˜å¤§å°çš„ stack frame

é€šå¸¸æƒ…å†µä¸‹ä¸€ä¸ª procedure çš„ stack frame çš„å¤§å°æ˜¯ç¡®å®šçš„ï¼Œä½†æœ‰æ—¶ stack frame çš„å¤§å°æ˜¯ä¸èƒ½åœ¨ç¼–è¯‘æ—¶ç¡®å®šçš„ï¼ˆä¾‹å¦‚æœ‰éç¡®å®šå¤§å°çš„æ•°ç»„ï¼‰ã€‚

stack frame å¤§å°ç¡®å®šä¸»è¦æ˜¯ä¸ºäº†èƒ½å¤Ÿé€šè¿‡ä¸ `%rsp` å³æ ˆé¡¶çš„ç›¸å¯¹è·ç¦»æ¥è®¿é—®å±€éƒ¨å˜é‡ç­‰ï¼Œåœ¨ stack frame å¤§å°ä¸ç¡®å®šæ—¶ï¼Œåˆ™å¯ä»¥é€šè¿‡è®°å½• stack frame åº•éƒ¨çš„åœ°å€æ¥è®¿é—®å±€éƒ¨å˜é‡ã€‚

<Card type="hint" title="stack frame pointer çš„åŸåˆ™">
    åœ¨ stack frame å¤§å°ä¸ç¡®å®šæ—¶ï¼Œä½¿ç”¨ `%rbp` ä½œä¸º frame pointer (base
    pointer)ï¼Œå…¶å€¼ä¸ºåˆšè¿›å…¥ procedure æ—¶çš„ `%rsp`ã€‚
</Card>

å…·ä½“å®ç°ä¸ºï¼š

```asm
function_name:
    pushq %rbp
    movq %rsp, %rbp
    â€¦â€¦
    leave
    ret
```

è®¾ç½®å¥½ `%rbp` åï¼Œå°±å¯ä»¥ä½¿ç”¨ `-8(%rbp)` ç­‰æ–¹å¼è®¿é—®ç›¸å¯¹äº stack frame åº•ç«¯çš„ä½ç½®äº†ã€‚

è¿™é‡Œæœ‰ä¸€ä¸ªæ–°æŒ‡ä»¤ `leave`: æ²¡æœ‰ operandï¼Œç›¸å½“äº `move %rbp, %rsp` ç„¶å `pop %rbp`ã€‚

<Card title="<code>leave</code> vs <code>enter</code>">
    ä¸Šé¢çš„ä»£ç ä¸­ä½¿ç”¨äº† `leave` è€Œé `move %rbp, %rsp`ã€`pop %rbp`ï¼Œä½†æ²¡æœ‰ä½¿ç”¨
    `enter` æŒ‡ä»¤ï¼Œç®€å•æ¥è¯´æ˜¯å†å²ä»¥åŠæ€§èƒ½åŸå› ï¼Œå¯ä»¥å‚è€ƒ [assembly - "enter" vs
    "push ebp; mov ebp, esp; sub esp, imm" and "leave" vs "mov esp, ebp; pop
    ebp" - Stack
    Overflow](https://stackoverflow.com/questions/5959890/enter-vs-push-ebp-mov-ebp-esp-sub-esp-imm-and-leave-vs-mov-esp-ebp)ã€‚
</Card>

é™¤äº†ä½¿ç”¨ `%rbp` ä½œä¸º frame pointerï¼Œä¸ºéç¡®å®šå¤§å°çš„æ•°ç»„åˆ†é…æ ˆç©ºé—´è¿˜æ¶‰åŠåˆ° [data alignment](#data-alignment) çš„é—®é¢˜ï¼Œå¯ä»¥å‚è€ƒ CS:APP Practice Problem 3.49ã€‚

### Stack Frame Alignment

x86-64 ä¸­è¦æ±‚ stack frame ä»¥ 16 byte å¯¹é½ã€‚å…·ä½“æ¥è¯´ï¼Œå°±æ˜¯æ‰§è¡Œ `call` ä¹‹å‰ `%rsp` çš„å€¼å¿…é¡»æ˜¯ 16 çš„å€æ•°ï¼Œè€Œåœ¨è¿›å…¥ä¸€ä¸ª procedure æ—¶ `%rsp` çš„å€¼å°±æ¨¡ 16 ä½™ 8ã€‚

ä¸ºäº†æ»¡è¶³è¿™ä¸€å¯¹é½è¦æ±‚ï¼Œæœ‰æ—¶ä¼šåœ¨ `call` ä¹‹å‰å…ˆ `subq $8, %rsp`ï¼Œ`call` ä¹‹åå† `addq $8, %rsp`ã€‚

## Array Allocation and Access

ç®€å•æ¥è¯´ï¼Œ`Imm(rb, ri, s)` çš„ operand æ ¼å¼ä½¿å¾—æ•°ç»„è®¿é—®å˜å¾—å®¹æ˜“ã€‚

è€Œç¼–è¯‘å™¨ä¼šåšå¾ˆå¤šä¼˜åŒ–ï¼Œä¾‹å¦‚ç”¨æŒ‡é’ˆåŠ æ³•ä»£æ›¿æ¯æ¬¡éƒ½ç®—ä¸€éä¹˜æ³•ã€‚

## Heterogeneous Data Structures

### Struct

ç»“æ„ä½“ä¹Ÿæ˜¯å†…å­˜ä¸­è¿ç»­çš„ä¸€æ®µï¼Œä¼šåœ¨ç¼–è¯‘æ—¶åœ¨ç»“æ„ä½“åœ°å€çš„åŸºç¡€ä¸ŠåŠ ä¸Šç›¸åº”çš„ offset æ¥è®¿é—®å„ä¸ª fieldã€‚

### Union

union çš„å¤§å°æ˜¯æœ€å¤§çš„ field çš„å¤§å°ï¼Œæ¯ä¸ª field çš„ offset éƒ½æ˜¯ 0ã€‚

åœ¨ä½¿ç”¨ union æ—¶ï¼Œbyte ordering å¯èƒ½éå¸¸é‡è¦ã€‚

### Data Alignment

åœ¨ x86-64 ä¸­ï¼Œè¿›è¡Œ data alignment å¯ä»¥æå‡ç¨‹åºæ•ˆç‡ã€‚å…·ä½“è¦æ±‚ä¸ºï¼Œä»»ä½•ï¼ˆä¸»è¦æ˜¯ç»“æ„ä½“å†…çš„ï¼‰primitive type çš„åœ°å€éœ€è¦æ˜¯å…¶é•¿åº¦çš„å€æ•°ã€‚

ä¸ºäº†æ»¡è¶³ alignment è¦æ±‚ï¼Œå¯èƒ½éœ€è¦ï¼š

1.  åœ¨ç»“æ„ä½“çš„ä¸åŒ field ä¹‹é—´æ·»åŠ  padding
2.  ä¿è¯ç»“æ„ä½“è‡ªèº«çš„åœ°å€æ˜¯å…¶è‡ªèº« alignment çš„å€æ•°
3.  åœ¨ç»“æ„ä½“æœ«å°¾æ·»åŠ  paddingï¼Œä¾‹å¦‚åœ¨æ•°ç»„ä¸­éœ€è¦ä¿è¯ä¸‹ä¸€ä¸ªå…ƒç´ çš„èµ·å§‹åœ°å€ä¸ºå…¶ alignment çš„å€æ•°

æ±‡ç¼–ä»£ç ä¸­ä¼šä½¿ç”¨ `.align` directive æ¥æŒ‡å®š data alignmentã€‚

## Thwarting Buffer Overflow Attacks

äº†è§£äº† stack çš„æ„é€ ï¼Œå°±èƒ½æ›´åŠ æ˜ç™½æ•°ç»„è¶Šç•Œçš„å±å®³ï¼šå¯ä»¥ä¿®æ”¹ stack ä¸ŠåŒ…æ‹¬ caller address åœ¨å†…çš„æ•°æ®ï¼Œå¯¼è‡´ç¨‹åºå‡ºé”™æˆ–è·³è½¬åˆ°é”™è¯¯çš„ä½ç½®ï¼Œè€Œæ”»å‡»è€…å¯ä»¥åˆ©ç”¨è¿™ä¸€æ¼æ´è·³è½¬åˆ°è®¾è®¡å¥½çš„ä½ç½®ä»¥æ‰§è¡Œæ”»å‡»ä»£ç ã€‚

ä¸‹é¢æ˜¯ä¸€äº›æ— éœ€ä¿®æ”¹ç¨‹åºä»£ç å°±èƒ½åšåˆ°çš„é™ä½ buffer overflow å±å®³çš„æ–¹æ³•ï¼Œå½“ç„¶ï¼Œè¿™äº›æ–¹æ³•ä¹Ÿä¸æ˜¯ä¸‡èƒ½æˆ–æ€»æ˜¯æœ‰æ•ˆçš„ã€‚

### Stack Randomization

å¯ä»¥ä¿®æ”¹ stack çš„èµ·å§‹åœ°å€ï¼Œä»¥é™ä½æŒ‡ä»¤åœ°å€çš„å¯é¢„æµ‹æ€§ï¼Œå¢å¤§æ”»å‡»éš¾åº¦ã€‚è¿™åœ¨ Linux ä¸­å·²ç»æ˜¯æ ‡å‡†åšæ³•äº†ï¼Œæ˜¯ address-space layout randomization (ASLR) çš„ä¸€éƒ¨åˆ†ã€‚

æ”»å‡»è€…å¯ä»¥é€šè¿‡â€œnop sledâ€ï¼Œå³é€šè¿‡å¤§é‡ `nop` æŒ‡ä»¤æ¥å¢é•¿æ”»å‡»ä»£ç çš„é•¿åº¦ï¼Œæ¥é™ä½çŒœæµ‹æŒ‡ä»¤åœ°å€çš„éš¾åº¦ã€‚

### Stack Corruption Detection

gcc ä½¿ç”¨ _stack protector_ æ¥æ£€æµ‹ stack corruptionï¼Œä»¥é¿å… corrupted stack é€ æˆçš„å±å®³ã€‚

ç®€å•æ¥è¯´ï¼Œä½¿ç”¨ stack protector æ—¶ï¼Œä¼šåœ¨ stack frame ä¸­æ’å…¥ä¸€ä¸ªè¿è¡Œæ—¶éšæœºç”Ÿæˆçš„ _canary value_ (_guard value_) ï¼Œå¹¶åœ¨ `ret` å‰æ£€æŸ¥è¿™ä¸ªå€¼æ˜¯å¦è¢«ä¿®æ”¹ã€‚

### Limiting Executable Code Regions

å¯ä»¥é™åˆ¶èƒ½å¤Ÿè¢«æ‰§è¡Œçš„ memory regionï¼Œä»¥é¿å…æ”»å‡»è€…æ‰§è¡Œä½äº stack ä¸­çš„ã€ç”±æ”»å‡»è€…æ³¨å…¥çš„æŒ‡ä»¤ã€‚

ä½†æ˜¯ï¼Œæœ‰çš„è¯­è¨€ï¼ˆä¾‹å¦‚ Javaï¼‰å¯èƒ½éœ€è¦èƒ½å¤Ÿæ‰§è¡ŒåŠ¨æ€ç”Ÿæˆçš„æŒ‡ä»¤ï¼Œè¿™æ ·çš„è¯å°±ä¸èƒ½ç¦æ­¢æ‰§è¡Œ stack ä¸­çš„æŒ‡ä»¤ã€‚

## Floating-Point Code

è¿™éƒ¨åˆ†å†…å®¹åŸºäº AVX2 æŒ‡ä»¤é›†ï¼Œå¯ä»¥æŒ‡å®š `-mavx2` é€‰é¡¹æ¥è®©ç¼–è¯‘å™¨ä½¿ç”¨ AVX2 æŒ‡ä»¤ã€‚

å¦‚æœä¸æ”¯æŒ AVXï¼Œåˆ™å¯ä»¥ä½¿ç”¨ SSE æŒ‡ä»¤é›†ï¼Œå¤§ä½“ä¸Šæ˜¯ç±»ä¼¼çš„ã€‚ç®€å•æ¥è¯´ï¼Œä¸»è¦çš„åŒºåˆ«å°±æ˜¯ AVX æŒ‡ä»¤çš„åç§°ä¼šæœ‰ä¸€ä¸ª `v` çš„å‰ç¼€ï¼Œè€Œå¾ˆå¤š AVX ä¸­ä¸‰ä¸ª operand çš„æŒ‡ä»¤åœ¨ SSE ä¸­æ˜¯ä¸¤ä¸ª operandã€‚

### YMM å¯„å­˜å™¨

æµ®ç‚¹æ•°å­˜æ”¾åœ¨ 16 ä¸ª YMM registers ä¸­ï¼Œæ¯ä¸ªå¯„å­˜å™¨æœ‰ 256 bitsï¼Œå«åš `%ymm0-15`ï¼Œè€Œä½ä½ 128 bits å«åš `%xmm0-15`ã€‚

è¿™äº›å¯„å­˜å™¨å¯ä»¥å­˜å¤šä¸ªæµ®ç‚¹æ•° (packed data) å¹¶å¯¹å®ƒä»¬åŒæ—¶è¿›è¡Œæ“ä½œä»¥åŠ é€Ÿè®¡ç®—ï¼›è€Œå¦‚æœåªå¯¹å•ä¸ªæµ®ç‚¹æ•° (scalar) è¿›è¡Œæ“ä½œï¼Œå°±åªæ¶‰åŠåˆ° `%xmm0-15` çš„ä½ä½ã€‚

### æµ®ç‚¹æ•°çš„ç§»åŠ¨æŒ‡ä»¤

ä¸‹é¢çš„æŒ‡ä»¤éƒ½æ²¡æœ‰åˆ—å…¨å¯èƒ½çš„ operand ç±»å‹ï¼Œä»…åˆ—å‡º CS:APP é‡Œè®²åˆ°çš„å¸¸ç”¨çš„ã€‚

-   `vmovss m32, xmm`
-   `vmovss xmm, m32`
-   `vmovsd m64, xmm`
-   `vmovsd xmm, m64`
-   `vmovaps xmm, xmm`
-   `vmovapd xmm, xmm`

å…¶ä¸­ `v` æ˜¯ AVX æŒ‡ä»¤çš„å‰ç¼€ï¼Œ`ss` è¡¨ç¤º scalar single-precisionï¼Œ`sd` è¡¨ç¤º scalar double-precisionï¼Œ`a` è¡¨ç¤º alignedï¼Œ`ps` è¡¨ç¤º packed single-precisionï¼Œ`pd` è¡¨ç¤º packed double-precisionã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ`s` ç»“å°¾çš„ç”¨äº floatï¼Œ`d` ç»“å°¾çš„ç”¨äº doubleã€‚

### æµ®ç‚¹æ•°ç±»å‹è½¬æ¢

#### æµ®ç‚¹æ•°è½¬ä¸ºæ•´æ•°

-   `vcvttss2si xmm/m32, r32`
-   `vcvttsd2si xmm/m64, r32`
-   `vcvttss2siq xmm/m32, r64`
-   `vcvttsd2siq xmm/m64, r64`

å…¶ä¸­ `cvttss2si` çš„æ„æ€æ˜¯: `cvt` -> convert, `t` -> (with) truncation, `ss` -> scalar single-precision, `2` -> to, `si` -> signed integerã€‚

`ss` ç”¨äº floatï¼Œ`sd` ç”¨äº doubleï¼›ç»“å°¾ä¸º `q` çš„ç”¨æ¥è½¬æˆ 64 ä½æ•´æ•°ã€‚

#### æ•´æ•°è½¬ä¸ºæµ®ç‚¹æ•°

-   `vcvtsi2ss r/m32, xmm, xmm`
-   `vcvtsi2sd r/m32, xmm, xmm`
-   `vcvtsi2ssq r/m64, xmm, xmm`
-   `vcvtsi2sdq r/m64, xmm, xmm`

è¿™é‡Œ `cvt` åå°‘äº†ä¸€ä¸ª `t` æ˜¯å› ä¸ºæ•´æ•°è½¬ä¸ºæµ®ç‚¹æ•°ä¸ä¼š truncateã€‚

æ•ˆæœæ˜¯æŠŠç¬¬ä¸€ä¸ª operand è½¬æ¢åæ”¾åœ¨ç¬¬ä¸‰ä¸ª operand å¤„ï¼Œè€Œç¬¬äºŒä¸ª operand ä¸€èˆ¬ä¸ç”¨ç®¡ï¼Œè®¾ä¸ºå’Œç¬¬ä¸‰ä¸ª operand ä¸€æ ·å³å¯ã€‚ï¼ˆè½¬æ¢ç»“æœä¼šæ”¾åœ¨ destination çš„ä½ä½ï¼Œè€Œç¬¬äºŒä¸ª operand ç”¨æ¥è®¾ç½® destination çš„é«˜ä½ã€‚ï¼‰

#### æµ®ç‚¹æ•°ç²¾åº¦è½¬æ¢

-   `vcvtss2sd xmm, xmm, xmm`
-   `vcvtsd2ss xmm, xmm, xmm`

operand çš„ä½œç”¨å’Œä¸Šé¢æ•´æ•°è½¬ä¸ºæµ®ç‚¹æ•°çš„æŒ‡ä»¤ä¸€æ ·ã€‚

<Card title="gcc ä½¿ç”¨çš„æµ®ç‚¹æ•°ç²¾åº¦è½¬æ¢æŒ‡ä»¤">
    åœ¨æŸäº›ç‰ˆæœ¬çš„ gcc ä¸­ï¼Œæˆ–é’ˆå¯¹æŸäº›å¤„ç†å™¨æ¶æ„è¿›è¡Œä¼˜åŒ–æ—¶ï¼Œgcc
    å¯èƒ½ä¼šä½¿ç”¨å¦å¤–çš„æŒ‡ä»¤æ¥è¿›è¡Œæµ®ç‚¹æ•°ç²¾åº¦è½¬æ¢ã€‚è¯¦è§
    [å¦ä¸€ç¯‡åšå®¢](/post/2022/10/gcc-use_vector_fp_converts)ã€‚
</Card>

### å‡½æ•°è°ƒç”¨ä¸­çš„æµ®ç‚¹æ•°

-   å‰ 7 ä¸ªæµ®ç‚¹å‚æ•°å¯ä»¥å­˜åœ¨ `%xmm0-7` ä¸­ï¼Œå…¶ä½™å‚æ•°å­˜åœ¨ stack é‡Œã€‚
-   æµ®ç‚¹å‡½æ•°è¿”å›å€¼å­˜åœ¨ `%xmm0` ä¸­ã€‚
-   æ²¡æœ‰ callee-saved å¯„å­˜å™¨ï¼ˆæ‰€æœ‰å¯„å­˜å™¨éƒ½æ˜¯ caller-savedï¼‰ã€‚

çœ‹å‚æ•°æ˜¯ç¬¬å‡ ä¸ªã€æ”¾åœ¨å“ªä¸ªå¯„å­˜å™¨æ—¶ï¼Œæµ®ç‚¹å‚æ•°å’Œæ•´å‹å‚æ•°æ˜¯åˆ†å¼€ç®—çš„ï¼Œä¾‹å¦‚ `double f1(int x, double y, long z)` å’Œ `double f2(double y, int x, long z)` çš„å‚æ•°å¯„å­˜å™¨åˆ†é…æ˜¯ç›¸åŒçš„ã€‚

### æµ®ç‚¹æ•°ç®—æœ¯è¿ç®—

ä¸‹é¢çš„æŒ‡ä»¤æŠŠ `ss` æ¢æˆ `sd`ã€`m32` æ¢æˆ `m64` å³ä¸º double-precision çš„ç‰ˆæœ¬ã€‚

#### æµ®ç‚¹æ•°äºŒå…ƒè¿ç®—

è®°ä¸‰ä¸ª operand åˆ†åˆ«ä¸º $S_1, S_2, D$ï¼Œåˆ™æ•ˆæœä¸ºè®¡ç®— $S_2$ ä¸ $S_1$ çš„è¿ç®—ç»“æœï¼Œå­˜åœ¨ $D$ ä¸­ï¼Œä¾‹å¦‚ `vsubss S_1 S_2 D` æ˜¯ $D \gets S_2 - S_1$ã€‚

-   `vaddss xmm/m32, xmm, xmm`
-   `vsubss xmm/m32, xmm, xmm`
-   `vmulss xmm/m32, xmm, xmm`
-   `vdivss xmm/m32, xmm, xmm`
-   `vmaxss xmm/m32, xmm, xmm`
-   `vminss xmm/m32, xmm, xmm`

#### æµ®ç‚¹æ•°ä¸€å…ƒè¿ç®—

`sqrtss xmm/m32, xmm`: å°† source å¼€æ–¹å­˜å…¥ destination

è¿™é‡Œ CS:APP ä¸­åˆ—å‡ºçš„æ˜¯ SSE æŒ‡ä»¤ `sqrtss` è€Œé AVX æŒ‡ä»¤ `vsqrtss`ï¼Œæˆ‘è‡ªå·±ç¼–è¯‘å‡ºæ¥ä¹Ÿæ˜¯ã€‚å¯èƒ½å¯ä»¥å‚è€ƒ [c++ - Using AVX intrinsics instead of SSE does not improve speed -- why? - Stack Overflow](https://stackoverflow.com/questions/8924729/using-avx-intrinsics-instead-of-sse-does-not-improve-speed-why)ã€‚

### æµ®ç‚¹æ•°å¸¸é‡

æµ®ç‚¹æ•°ç›¸å…³çš„æŒ‡ä»¤ä¸æ¥å— immediate value ä½œä¸º operandï¼Œæ‰€ä»¥ä½¿ç”¨å¸¸é‡æ—¶éœ€è¦å…ˆå­˜ä¸‹æ¥ï¼Œä¾‹å¦‚ï¼š

```c
double foo() { return 1.8; }
```

```asm
foo:
	vmovsd	.LC0(%rip), %xmm0
	ret
.LC0:
	.long	-858993459
	.long	1073532108
```

### æµ®ç‚¹æ•°ä½è¿ç®—

ä½è¿ç®—éƒ½æ˜¯åœ¨æ•´ä¸ªå¯„å­˜å™¨ä¸Šå¯¹ packed data è¿›è¡Œçš„ã€‚

-   `vxorps xmm/m128, xmm, xmm`
-   `vxorpd xmm/m128, xmm, xmm`
-   `vandps xmm/m128, xmm, xmm`
-   `vandpd xmm/m128, xmm, xmm`

operands æ ¼å¼å’Œä¸Šé¢ä¸€æ ·ã€‚

ä¸€äº›æµ®ç‚¹æ•°ä½è¿ç®—çš„å®é™…è¿ç”¨ï¼š

-   ç”¨ and è¿ç®—å°† sign bit ç½®é›¶ï¼Œä»¥å–ç»å¯¹å€¼
-   ç”¨ xor è¿ç®—å°† sign bit å–åï¼Œä»¥å–ç›¸åæ•°
-   å°† xor çš„ä¸¤ä¸ª source è®¾ä¸ºåŒä¸€ä¸ªå¯„å­˜å™¨ä»¥å¾—åˆ° 0

<Card
    type="question"
    title="packed single/double precision åœ¨ç§»åŠ¨å’Œä½è¿ç®—ä¸Šçš„åŒºåˆ«ï¼Ÿ"
>
    `vmovaps` å’Œ `vmovapd`ã€`vxorps` å’Œ `vxorpd`ã€`vandps` å’Œ `vandpd`
    çœ‹èµ·æ¥æ•ˆæœæ˜¯ä¸€æ ·çš„ï¼Œä¸ºä»€ä¹ˆè¦ç»™ single/double precision åˆ†åˆ«ä¸€æ¡æŒ‡ä»¤å‘¢ ğŸ¤”
</Card>

### æµ®ç‚¹æ•°æ¯”è¾ƒ

-   `vucomiss xmm/m32, xmm`
-   `vucomisd xmm/m64, xmm`

æ•ˆæœä¸ºï¼Œè®¡ç®—ç¬¬äºŒä¸ª operand å‡å»ç¬¬ä¸€ä¸ª operand å¹¶è®¾ç½® status flagsã€‚

æµ®ç‚¹æ•°çš„æ¯”è¾ƒæ˜¯â€œunorderedâ€çš„ï¼Œå³è‹¥æŸä¸ª operand æ˜¯ NaNï¼Œåˆ™æ¯”è¾ƒç»“æœä¸º unorderedã€‚

ä¸åŒçš„æ¯”è¾ƒç»“æœå¯¹åº”çš„ status flags ä»¥åŠ condition code ä¸ºï¼š

|  æ¯”è¾ƒç»“æœ   | CF  | ZF  | PF  | condition code |
| :---------: | :-: | :-: | :-: | :------------: |
|  unordered  |  1  |  1  |  1  |      `p`       |
| $S_2 < S_1$ |  1  |  0  |  0  |      `b`       |
| $S_2 = S_1$ |  0  |  1  |  0  |      `e`       |
| $S_2 > S_1$ |  0  |  0  |  0  |      `a`       |

å…¶ä¸­ PF åœ¨æµ®ç‚¹æ•°æ¯”è¾ƒä¸­ç”¨æ¥è¡¨ç¤º unorderedï¼Œåœ¨æ•´æ•°è®¡ç®—ä¸­ä¹Ÿä¼šè¢«è®¾ç½®ä½†å‡ ä¹æ²¡ç”¨ã€‚
