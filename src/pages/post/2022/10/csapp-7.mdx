---
title: CS:APP 第七章学习笔记
date: 2022-10-17T10:56:55+08:00
image: /images/2022/10/csapp-7.png
tags:
-   csapp
-   计算机系统
-   学习笔记
-   WIP
---

[CS:APP](https://csapp.cs.cmu.edu/) 第七章“Linking”的学习笔记。

这章的主要内容为程序的链接。学习链接有助于：理解链接报错，避免链接相关的 bug，理解变量（函数）的作用域，理解程序运行过程中与链接相关的步骤，了解如何使用共享库（动态链接库）。

<Excerpt />

## Compiler Drivers

编译源文件其实分成若干步骤，compiler driver（如 gcc）会依次调用这些步骤，可以用 `gcc -v` 来查看这些步骤的详细信息。

1.  `cpp`: 预处理，源代码 `.c` ->  intermediate file `.i`
2.  `cc1`: `.i` -> 汇编代码 `.s`
3.  `as`: `.s` -> relocatable object file `.o`
4.  `ld`: 链接，多个 `.o` (或 library) -> executable object file

P.S. 中间步骤的文件也可以作为参数传递给 `gcc`，例如 `gcc a.s -o a`。

## Static Linking

静态链接主要有两个任务：

1.  *Symbol resolution*: relocatable object file 中有很多 symbol，包括函数、全局变量、静态变量等，linker 需要将每个 symbol reference 对应到一个 symbol definition。
2.  *Relocation*: relocatable object file 中地址从 0 开始，linker 需要将每个 symbol definition 重新分配到正确的地址，并相应地修改每个 symbol reference。

## Object Files

object file 分为三种：

1.  Relocatable object file
2.  Executable object file
3.  Shared object file: 一种特殊的 relocatable object file，可以在 load time 或 run time 进行动态链接

object file 有不同的格式，Windows 使用 Portable Executable (PE) 格式，macOS 使用 Mach-O 格式，现代的 x86-64 Linux/Unix 系统使用 Executable and Linkable Format (ELF) 格式。本章会基于 ELF-64。

## Relocatable Object Files

ELF relocatable object file 通常包含以下 section：

1.  `.text`: 程序的机器码
2.  `.rodata`: 只读的数据
3.  `.data`: 需要初始化的全局变量和静态变量
4.  `.bss`: 未初始化或初始化为零的全局变量和静态变量，它们在运行时会以零为初值，从而在 object file 中不占据文件大小
5.  `.symtab`: symbol table，存储 symbol（函数、全局变量）的信息，不需要 `-g` 编译选项，但不含局部变量的信息
6.  `.rel.text`: 列出了 `.text` 中在链接时需要修改的地方，一般是调用外部函数或引用全局变量时需要修改，而 [调用本地函数不需要修改](/post/2022/09/csapp-3#jump-指令编码)
7.  `.rel.data`: 列出了 `.data` 中在链接时需要修改的地方，一般是全局变量的值为其他全局变量或外部函数的地址时需要修改
8.  `.debug`: 调试信息，包含局部变量的信息、typedef 信息、源代码等，需要 `-g` 编译选项才有
9.  `.line`: 源代码与机器码行号间的对应关系，需要 `-g` 编译选项才有
10. `.strtab`: 一堆字符，用于其它 section，可以指向其中一个位置来表示一个字符串（从这个位置起到 `\0` 为止）

## Symbols and Symbol Tables

对 linker 来说，symbol 有三种：

1.  本地定义，可以被外部访问的: C 中非 `static` 的函数和全局变量
2.  外部定义的，例如 C 中 `extern` 的全局变量
3.  本地定义，外部不可访问的: C 中 `static` 的函数和变量

一个 ELF64 symbol 包含如下信息（CS:APP Figure 7.4）：

```c
typedef struct
{
    int   name;      /* String table offset */
    char  type:4,    /* Function or data (4 bits) */
          binding:4; /* Local or global (4 bits) */
    char  reserved;  /* Unused */
    short section;   /* Section header index */
    long  value;     /* Section offset or absolute address */
    long  size;      /* Object size in bytes */
} Elf64_Symbol;
```

`value` 在 relocatable object file 中是 symbol 的地址相对于 section 开头的 offset，在 executable object file 中是 symbol 的绝对地址。

`section` 是 object file 的 section 之一（的 index），在 relocatable object file 中还可以是一个 pseudosection:

-   ABS: 不应被 relocate 的 symbol
-   UNDEF: 未定义（在其他 module 中定义）的 symbol
-   COMMON: 多个 module 共用的 symbol（见 [Symbol Resolution](#symbol-resolution)），此时 `value` 的值给出 data alignment 的要求，`size` 给出的是 minimum size

未初始化的静态变量以及初始化为零的全局或静态变量会放在 `.bss`。

未初始化的全局变量，如果启用了 `-fcommon` 编译选项则会放在 COMMON，否则放在 `.bss`。在 gcc 9 及之前默认选项是 `-fcommon`，而自 gcc 10 起默认选项是 `-fno-common`。在 C++ 中 `-fcommon` 是无效的，未初始化的全局变量总是放在 `.bss`。

可以使用 `readelf -s a.o` 来查看 `a.o` 的 `.symtab`。

## Symbol Resolution

Symbol resolution 即把每个 symbol reference 对应到一个 symbol definition。

local symbol 的 resolution 是容易的，因为编译单个 module 时就保证了 local symbol 是唯一的。

global symbol 可能遇到几种情况：

-   只有一个 module 里定义了这个 global symbol，则使用这个 symbol
-   没有任何 module 里定义了这个 global symbol，则报错 undefined reference
-   在多个 module 里定义了这个 global symbol，则：
    -   如果其中有多个 symbol 不在 COMMON 段，则报错 multiple definition
    -   如果其中只有一个不在 COMMON 段，则使用这个 symbol
    -   如果这些 symbol 都在 COMMON 段，则使用其中 `size` 最大的一个（如果 `size` 相同则使用哪个是没有区别的）；如果这些 symbol 有不一样的 `size`，linker 还会给出警告

也就是说，若编译选项为 `-fcommon`，如果在多个 module 中定义了同一个全局变量且其中最多有一个初始化了，则可能导致意外的结果。可以理解为，multiple definition 在本质上是 multiple initialization。

在 C++ 中，函数重载、类方法会通过 *mangling* 来使得函数的每种重载有独特的 symbol name。

## Static Libraries

Static library 其实就是一堆 object file 包装在一起，它的好处是：

1.  不用每次重新编译（比起提供源码）
2.  使得库和编译器解耦（比起将库函数内置到编译器中）
3.  只需将用到的 object file 复制到最终的可执行文件中，避免空间浪费（比起提供单个 object file）
4.  可以自动选择用到的 object file，在编译命令中只需指定少量库的名称（比起提供一堆 object file）

可以使用类似 `ar rcs libabc.a a.o b.o c.o` 的命令来创建一个 static library。

在编译时，有两种使用 static library 的方式：

-   直接将 static library 的路径作为参数: `libabc.a`
-   使用 `-lname` 来使用 `libname.a`，但需要使用 `-Ldir` 来将 `dir` 加入到 `-l` 的搜索路径之中: `-L. -labc`

特别地，编译器会自动将 `libc.a` 提供给 linker，不需要手动指定。

在链接时，linker 会依次处理每个参数：

-   如果一个参数是 object file 就一定会使用
-   如果是 static library，则会依次查看其中包含的每一个 object file，如果一个 object file 中定义了某个当前引用了但仍未定义的 symbol，则会使用这个 object file，而这样的过程会反复迭代进行直到没有新的 object file 被使用为止（例如 `main.c` 引用了 `b.o` 而没有引用 `a.o`，而 `b.o` 中引用了 `a.o`，且在 `libabc.a` 中 `a.o` 位于 `b.o` 之前，那么第一次迭代中只会使用 `b.o`，第二次迭代才会使用 `a.o`，而 `c.o` 不会被使用）

这样的过程使得编译命令中参数的顺序以及 static library 中 object file 的顺序可能影响编译结果：

-   一般来说需要将 library 放在编译命令的末尾，否则处理一个 library 时还没有引用其中的 symbol，就不会使用相应的 object file，最后就会报错 undefined reference
-   如果多个 library 之间有依赖关系，需要将被其他 library 依赖的 library 放在靠后的位置
-   如果多个 library 之间有循环依赖，可能需要在编译命令中多次指定同一个 library（或者也可以将这两个 library 合并成一个，这样的话通过多次迭代就可以解决循环依赖）
-   library 的设计应当避免 multiple definition，但理论上存在不同的参数顺序或 static library 中 object file 的顺序导致 multiple definition 的可能

## Relocation

relocation 分为两步：

1.  给 symbol definition 重新分配内存地址
2.  相应地修改 symbol reference

第一步是简单的，把各个 object file 中的各个 section 分别拼在一起即可。

为了让 linker 知道如何修改 symbol reference，需要让 linker 知道：

1.  需要被修改的 symbol reference 在哪
2.  需要修改成什么

在 relocatable object file 的 `.rel.text` 和 `.rel.data` 中存放了相关的信息，一条这样的信息称作一个 relocation entry，包含的内容为：

-   `offset`: 这个 symbol reference 相对于其所在的 section 的偏移量。也就是说，在这个 reference 所在的 section 的地址的基础上加上 `offset` 就得到了这个 reference 的地址。
-   `type`: 有很多种 relocation，CS:APP 中只介绍其中的 `R_X86_64_PC32` 和 `R_X86_64_32` 两种。
-   `symbol`: 被 reference 的 symbol 在 symbol table 中的 index。
-   `addend`: 计算 symbol 地址时加在最后的常数（见后文）。

简单来说，`R_X86_64_32` 使用绝对地址进行定位，`R_X86_64_PC32` 使用相对于 PC 的地址进行定位，且这两种类型的 relocation 都只支持 32 位的地址（如果一个程序的大小超过 2GB，就需要指定编译选项 `-mcmodel=medium/large`）。

-   `R_X86_64_32`: 修改后的 reference 为 symbol 的地址加上 `addend`
-   `R_X86_64_PC32`: 修改后的 reference 为 symbol 的地址与 reference 的地址之差加上 `addend`；需要注意的是，是与 reference 的地址之差，而不是与执行到 reference 所在语句时的 PC 之差，所以通常会需要通过 `addend` 来修正

可以使用 `objdump -dx` 以在反汇编结果中显示 relocation entry，或者使用 `readelf -r` 显示所有 relocation entry。

例如，使用 GCC 8.5 编译

```c
int foo(int *arr);

int a[3] = {1, 2, 3};
int *b = &a[2];

int bar()
{
    return foo(&a[1]);
}
```

`readelf -r`:

```
Relocation section '.rela.text' at offset 0x250 contains 2 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000001  000a0000000a R_X86_64_32       0000000000000008 a + 4
000000000006  000b00000002 R_X86_64_PC32     0000000000000000 foo - 4

Relocation section '.rela.data' at offset 0x280 contains 1 entry:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000000  000a00000001 R_X86_64_64       0000000000000008 a + 8
```

在 `.rela.text` 中，`a` 的 `addend` 是 `4`，是直接得到 `a[1]` 而非 `a[0]` 的地址；`foo` 的 `addend` 是 `-4`，是因为 reference 的地址是 reference 所在的 `jmp` 指令的下一条指令的地址减 4，导致 PC 的地址加上 `foo` 的地址减去 reference 的地址得到的是 `foo` 的地址加 4，需要 `addend` 来修正。

## Executable Object Files

可执行文件的内容大体上和 relocatable object file 类似，主要的区别是：

-   在 ELF header 中指定了程序的 entry point
-   有一个 `.init` section，定义了一个简单的函数，用来初始化程序
-   有一个 program header table，描述了程序文件与内存的对应关系，即要把文件的哪一段映射到内存的哪一段，地址如何对齐，以及每一段的权限（`.init`、`.text`、`.rodata` 的权限为 `r-x`，`.data` 和 `.bss` 的权限为 `rw-`）
-   `.symtab`、`.debug`、`.line`、`.strtab` 在执行时不会加载到内存中
-   如果 fully linked，则没有 `.rel` section

## Loading Executable Object Files

在程序运行时，run-time memory image 大致如下图（CS:APP Figure 7.15）所示：

![Linux x86-64 run-time memory image](csapp-fig7.15.png)

因为地址对齐、address-space layout randomization 等原因，实际上的内存结构会与上图有一定的差异，但每一段的相对位置是和图中一致的。

loader 加载可执行文件时，首先创建 memory image，然后根据 program header table 将可执行文件的内容复制到内存中，最后跳转到程序的 entry point。C 语言程序的 entry point 是 `_start` 函数（在 `crt1.o` 中定义）的地址，`_start` 又会调用 `__libc_start_main` 函数（在 `libc.so` 中定义），进行运行环境的初始化，然后调用 `main` 函数，最后对返回值进行处理。
